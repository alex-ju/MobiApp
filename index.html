<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tree Example</title>
    <link rel="stylesheet" href="style1.css" />
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <meta http-equiv="content-type" content="text/html; charset=UTF8"> 

  </head>

  <body>

    <div>
      <div class="col-md-4 hidden" id="operation_manager">
        <div class="panel-group" id="operation_info">
          <div class="panel panel-default">
            <div class="panel-heading">
              <h4 class="panel-title">

                <a data-toggle="collapse" href="#collapse0"><span class="glyphicon glyphicon-cog"></span> Operation Manager</a>
                <button type="button" class="close" id="close_oManager"> <span aria-hidden="true">&times;</span><span class="sr-only">Close</span>
                </button>
              </h4>

            </div>
            <div class="panel-body">
              <div class="btn-group">
                <button type="button" id="path_button" class="btn btn-md btn-primary">Show only path</button>
                <button type="button" id="remove_button" class="btn btn-md btn-primary">Remove Operation</button>
                <button type="button" id="demo_button" class="btn btn-md btn-primary">Demo</button>
              </div>
              <div class="panel-group" id="operation_info">
                <div class="panel panel-default">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" class="info-toggle" href="#collapse_node"> Node View</a>
                    </h4>
                  </div>
                  <div id=collapse_node class="panel-body collapse in"> 
                    <div class="info scroll" id="info_view"></div>
                  </div>
                </div>
                <div class="panel panel-default">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" class="info-toggle" href="#collapse_builder"> Operation Builder</a>

                    </h4>
                  </div>
                  <div id=collapse_builder class="panel-body collapse in"> 
                    <ul class="nav nav-tabs" id="operation_types" style="margin-bottom:1px">
                      <li class="active"><a style="background-color:#f4fff5;" id="range_button" data-toggle="tab" href="#range">Range</a></li>
                      <li><a style="background-color:#fff7f7" data-toggle="tab" id="contains_button" href="#contains">Contains</a></li>
                    </ul>
                    <div class="tab-content">
                      <div id="range" class = "tab-pane fade in active">
                        <h5>Range Operation Builder</h5>
                        <!-- <button type="button" id="toggle_range_button" class="btn btn-primary">Toggle current/full range</button> -->
                        
                        <ul class="nav nav-pills nav-fill">
                          <li class="nav-item active">
                            <a class="nav-link" data-toggle="tab" id="filter_view" href="#r_filter" role="tab">Filter</a>
                          </li>
                          <li class="nav-item">
                            <a class="nav-link" data-toggle="tab" id="partition_view" href="#r_partition" role="tab">Partition</a>
                          </li>
                        </ul>
                        <div class="tab-content">
                          <div id="r_filter" class = "tab-pane fade in active panel-background" role="tabpanel">
                            <h6>Range Filter Builder</h6>
                            <div class="text-center">
                              
                              <div class="radio-inline">
                                <label class="range_radio"><input checked type="radio" id= "current_range_opt" name="optradio">Current Range</label>
                              </div>
                              <div class="radio-inline">
                                <label class="range_radio"><input type="radio" id="full_range_opt" name="optradio">Full Range</label>
                              </div>
                                <!-- <label class="btn btn-default center-block"><input type="radio">All</label>
                                <label class="btn btn-default active center-block"><input type="radio">Filtered</label> -->
                            </div>
                            <div  class="graph" id="build_filter_view"></div>
          
                            <div class="range_radio inline-center" id="input_filter_value">
                              <div>
                              Start: 
                              <!-- <input type="text" size="6" id="partition_value"> -->
                              <input type="text" size="6" id="range_start_value">
                              </div>
                              <div class="left-buffer">
                              End:
                              <input type="text" size="6" id="range_end_value">
                              </div>
                            </div>
                            <div class="text-right top-buffer">
                              <label class="checkbox-inline right-buffer"><input id="range_not_button" type="checkbox" value="">NOT</label>
                              <div class="btn-group">
                                <button type="button" id="applyFilter_button" class="btn btn-primary">Apply</button>
                              </div>
                            </div>
                          </div>
                          <div id="r_partition" class="tab-pane fade in panel-background" role="tabpanel">
                            <h6>Range Partition Builder</h6>
                            <div class="text-center">
                              <div class="radio-inline">
                                <label class="range_radio"><input checked type="radio" id= "current_range_opt2" name="optradio2">Current Range</label>
                              </div>
                              <div class="radio-inline">
                                <label class="range_radio"><input type="radio" id="full_range_opt2" name="optradio2">Full Range</label>
                              </div>
                            </div>
                            <div  class="graph" id="create_partition_view"></div>
                            <div class="inline">
                              <div class="btn-toolbar">
                                <!-- <button type="button" id="addPartition_button" class="btn btn-primary">Add Partition</button>

                                <button type="button" id="removePartition_button" class="btn btn-primary">Remove Partition</button> -->
                                <button class="btn btn-sm btn-success" id=addPartition_button type="button">
                                  <span class="glyphicon glyphicon-plus"></span>
                                </button>
                                <button class="btn btn-sm btn-danger" disabled id=removePartition_button type="button">
                                  <span class="glyphicon glyphicon-minus"></span>
                                </button>
                              </div>
                              <div class="left-buffer" id="input_partition_value">
                                <input type="text" size="10" id="partition_value">
                              </div>
                            </div>
                            <div class="text-right top-buffer">
                              <div class="btn-group">
                                <button type="button" id="applyPartition_button" class="btn btn-primary">Apply</button>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <div id="contains" class = "tab-pane fade in">
                        <h5>Contains Operation Builder</h5>
                        <div class="inline border">
                          <div  class="graph" id="pb_graph"></div>
                          <div style="width:140px;" >
                            <div class="text-center">
                              <button type="button" id="clear_pb_button" class="btn btn-sm btn-default btn-block">Clear All</button>
                            </div>
                            <div class="panel-group top-buffer-sm" id="operation_info">
                              <div class="panel panel-default">
                                <div class="panel-heading">
                                  Actions
                                  <a data-toggle="collapse" class="info-toggle" href="#collapse_actions"></a>
                                </div>
                                <div id=collapse_actions class="panel-body collapse in">

                                  
                                  <div class="btn-toolbar">
                                    <button class="btn btn-xs btn-success" id="add_node_button" type="button">
                                      <span class="glyphicon glyphicon-plus"></span>
                                    </button>
                                    <button class="btn btn-xs btn-danger" id="remove_node_button" type="button">
                                      <span class="glyphicon glyphicon-minus"></span>
                                    </button>
                                    <button class="btn btn-xs btn-default" id="toggle_many_button" type="button">
                                      1/+
                                    </button>
                                  </div>
                                  <div class='top-buffer-sm'>
                                    Actions:
                                    <div class="graph scroll border" style=" height: 110px; width: 100px;" id ="action_list"> </div>
                                  </div>
                                </div>

                              </div>
                              <div class="panel panel-default">
                                <div class="panel-heading">
                                  Links
                                  <a data-toggle="collapse" class="info-toggle" href="#collapse_links"></a>
                                </div>
                                <div id=collapse_links class="panel-body collapse in">
                                  <div class=btn-group-vertical data-toggle="buttons">
                                    <label class="btn btn-sm btn-default" id="add_cons_link_button"><input  name="link_radio" type="radio" >Consecutive</label>
                                    <label class="btn btn-sm btn-default" id="create_funnel_button"><input name="link_radio" type="radio" >Non-Consecutive</label>
                                  </div>
                                </div>
                              </div>
                            </div>


                          </div>
                          <!-- <div class="graph" id ="action_list"> </div> -->
                        </div>
                        <!-- <div class="btn-group-vertical">
                          
                          <button type="button" id="add_cons_link_button" class="btn 
                          btn-primary">Add Consecutive Links</button>
                          <button type="button" id="create_funnel_button" class="btn btn-primary">Add Non-Consecutive Links</button>
                     
                        </div> -->
                        <div class="text-right top-buffer">
                          <label class="checkbox-inline right-buffer"><input id="contains_not_button" type="checkbox" value="">NOT</label>
                          <div class="btn-group">
                            <button type="button" id="apply_contains_operation" class="btn btn-primary">Apply</button>
                            <button type="button" id="apply_funnel_button" class="btn btn-primary">Apply as Funnel</button>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class = "col-md-5" id="tree_view">
        <button type="button" id="toggle_oManager" class="btn btn-default"><span class="glyphicon glyphicon-cog"></span>
        </button>
        <h4 class="text-center"> 
        TREE DIAGRAM 
        </h4>
        <div class= "graph" id= "tree"></div>
      </div>
      <div class ="col-md-7" id="sequence_attributes">
        <div class="panel-group" id="segment_info">
          <div class="panel panel-info">
            <div class="panel-heading">
              <h4 class="panel-title">
                <a data-toggle="collapse" href="#collapse0"> Selected Segment Attributes</a>
              </h4>
            </div>
            <div id="collapse_segment" class="panel-body collapse in">
              <div class="panel-group" id="accordion">
                <div class="panel panel-success">
                  <div class="panel-heading">
                    <h4 class="panel-title"> 
                      <a data-toggle="collapse" class="info-toggle" href="#collapse1"></a>
                      Range Attributes
                      
                    </h4>
                  </div>
                  <div id="collapse1" class="panel-body collapse in">
                  

                    <div class="panel-group" id="range_attributes">

                      

                      <div class="panel panel-default">
                        <div class="panel-heading">
                          <h4 class="panel-title">
                            <a data-toggle="collapse" class="info-toggle" href="#collapse_time"></a>
                            <span class="glyphicon glyphicon-time"></span>
                            Time-Related
                          </h4>
                        </div>
                        <div id="collapse_time" class="panel-collapse collapse in">
                          <div class="panel-body">
                            <div class="chart" id="duration_chart"> 
                              <div class="title"> Duration chart </div>
                            </div>
                            <div class="chart" id="hour_chart"> 
                                <div class="title"> Start hour chart </div>
                            </div>
                            <div class="chart" id="date_chart"> 
                                <div class="title"> Start Date </div>
                            </div>
                          </div>
                        </div>
                      </div>

                      <div class="panel panel-default">
                        <div class="panel-heading">
                          <h4 class="panel-title">
                            <a data-toggle="collapse" class="info-toggle" href="#collapse_count"></a>
                            # Count-Related
                          </h4>
                        </div>
                        <div id="collapse_count" class="panel-collapse collapse in">
                          <div class="panel-body">
                            <div id="count_charts">
                              <div class="chart" id="len_chart"> 
                                <div class="title"> Number of Actions 
                                
                                </div>
                              </div>
                              <!-- <div class="chart" id="a_count_chart"> 
                                <div class="title"> Number of AddToCart </div>
                              </div> -->
                            </div>
                          </div>
                        </div>
                      </div> 

                    </div>
                  </div>
                  

                </div>
                <div class="panel panel-danger">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" class="info-toggle" href="#collapse_contains"></a>
                      Contains Attributes
                    </h4>
                  </div>
                  <div id="collapse_contains" class="panel-collapse collapse in">
                    <div class="panel-body">
                      <div class= "chart1" id="contains_action_chart">
                        <div class="title"> Number of Sequences that Contains Action </div>
                      </div>

                      <div class ="chart1" id="node_link">
                        <div id="cy"></div>
                      </div>
                      <div class="chart1" id="adjacency_chart">
                        <div id="tooltip" class="hidden">
                          <p><span id="value">100</span></p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="panel panel-warning">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" class="info-toggle" href="#collapse3"></a>
                      Sequence Details
                    </h4>
                  </div>
                  <div id="collapse3" class="panel-collapse collapse in">
                    <div class="panel-body">
                      <div id="sequences">
                        <label class="checkbox-inline"><input id="group_sequences" type="checkbox" value="">Group Sequences</label>
                        <label class="checkbox-inline"><input id="transitionize_sequences" type="checkbox" value="">Transitionize Sequences</label>
                    
                        <div id="sequences_text" class="border scroll" style=" height: 200px; width: 500px; margin-left: 20px; margin-top: 20px;"> 
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div> 
            </div>
          </div>
        </div>
      </div>
    </div>



<!-- load the d3.js library --> 
<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script> -->
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
<script
  src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
  integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU="
  crossorigin="anonymous"></script>

<script src="js/crossfilter.js"></script>
<script src="http://marvl.infotech.monash.edu/webcola/cola.v3.min.js"></script>
 <script src="cytoscape.js"></script>
<script src="cola.js"></script>
 <script src="cytoscape-cola.js"></script>
 <script src="https://cdn.rawgit.com/cpettitt/dagre/v0.7.4/dist/dagre.js"></script>
 <script src="cytoscape-dagre.js"></script>
 <script src="bootstrap/js/bootstrap.min.js"></script>



    
<script>

$(document).ready(function(){



  var selectedFilter ={},
      selectedDiv,
      selectedChar,
      selectedExtents,
      new_selection = false.
      thresholds = [20, 10, 5, 2, 1, 0];

  var dataset = []
  var parseDate = d3.timeParse("%Y-%m-%d %H:%M:%S.%L")
  //var parseTimeDelta = d3.timeParse("%d %H:%M:%S.%L")

  var csv_file = "sample_table.csv"; //100K
  //var csv_file = "sample_table1.6M.csv";
  var seq_data;



d3.csv(csv_file, function(error, data) {
  if (error) throw error;
  seq_data = data;

  d3.csv('alphabet1.csv', function(error1, alpha_data) {
      if (error1) throw error1;
      data= seq_data;

      data.forEach(function(d){

        d.len = +d.len;
        d.index = +d.index;
        d.start_index = +d.start_index;
        d.end_index = +d.end_index;
        d.start = parseDate(d.start);
        d.end = parseDate(d.end);
        d.dur = d.end -d.start;
      });


      alphabet = {},
      alphabet_rev = {};
      alpha_data.forEach(function(d){

        alphabet[d.Action] = d.Character;
        alphabet_rev[d.Character] = d.Action
      })
      var start_c = '0',
          exit_c = '1';
      alphabet['start'] = start_c;
      alphabet['exit'] = exit_c;
      alphabet_rev[start_c] = 'start';
      alphabet_rev[exit_c] = 'exit';

      console.log('Alphabet: ', alphabet);
      console.log(data[0])




    var colors = {

      "addToCart": "#79EA85",
      "removeFromCart": "#EA0000",
      "purchase": "#00AC22",
      "search": "#FF7100",
      "pageview": "#0073B9",
      "start": "#999",
      "exit": "#999"


    }

      function color(action){
        if (action in colors)
          return colors[action]
        else
          return 'none'
      }

      var action_counted = 'search'

      var seqs = crossfilter(data),
          all = seqs.groupAll(),


          len = seqs.dimension(function(d) {return d.len;}),
          l = seqs.dimension(function(d) {return d.len;}),
          lens = len.group(Math.floor),
          // lens = len.group(function(d) {
          //   //return group_count(d);
          //   return d;
          // }),
          
          
          hour = seqs.dimension(function(d) {return d.start.getHours() + d.start.getMinutes()/60;}),
          h = seqs.dimension(function(d) {return d.start.getHours() + d.start.getMinutes()/60;}),
          hours = hour.group(Math.floor),
          

          start = seqs.dimension(function(d) {return d.start}),
          start_filter = seqs.dimension(function(d) {return d.start}),
          starts = start.group(d3.timeDay);
          
          interval = 1000*60*60
          duration = seqs.dimension(function(d) {return (d.end - d.start)/(interval)});
          dur_filter = seqs.dimension(function(d) {return (d.end - d.start)/(interval)});
          durations = duration.group(Math.floor);

          action_strings = seqs.dimension(function(d) {return d.general_actions});
          action_strings2 = seqs.dimension(function(d) {return d.general_actions});
          strings_grouped = action_strings2.group()


          trans_strings = seqs.dimension(function(d) {return remove_duplicates(d.general_actions)});
          trans_grouped = trans_strings.group()

    //console.log(lens.top(Number.POSITIVE_INFINITY).length);
    

    function action_count(d, action){
      var c = alphabet[action],
          re = new RegExp(c,'g'),
          str = d.general_actions,
          matches = str.match(re);

      return matches? matches.length: 0
    }


    d3.selectAll("#sequence_details")
      .on("click", print_sequences);


    d3.select("#range_button")
      .on("click", show_range_builder);
    //d3.select("#build_filter_button")
    d3.select("#filter_view")
      .on("click", show_filter_builder)
    d3.select("#partition_view")
      .on("click", show_partition_view);
    d3.select("#contains_button")
      .on("click", show_contains_builder);
    d3.select("#remove_button")
      .on("click", remove_filter);
    d3.select("#segment_button")
      .on("click", toggle_segments);

    d3.select("#toggle_oManager")
      .on("click", toggle_operation_manager);
    d3.select("#close_oManager")
      .on("click", toggle_operation_manager);
    
    d3.select("#tree_info_button")
      .on("click", toggle_tree_info_view);
    d3.select("#path_button")
      .on("click", show_path_only);
    
    d3.select("#addPartition_button")
      .on("click", add_partition_bar);
    d3.select("#removePartition_button")
      .on("click", remove_partition_bar);
    d3.select("#applyPartition_button")
      .on("click", create_partition);

    d3.select("#full_range_opt")
      .on("click", update_to_full_range);
    d3.select("#current_range_opt")
      .on("click", update_to_current_range);
    d3.select("#applyFilter_button")
      .on("click", create_range_filter);
    d3.select("#range_not_button")
      .on("click", create_not_range_filter)
    
    d3.select("#add_node_button")
      .on("click", add_action_node);
    d3.select("#create_funnel_button")
      .on("click", create_funnel)
    d3.select("#apply_contains_operation")
      .on("click", apply_contains_filter)
    d3.select("#apply_funnel_button")
      .on("click", apply_funnel)
    d3.select("#remove_node_button")
      .on("click", remove_action_node)
    d3.select("#add_cons_link_button")
      .on("click", add_link)
    d3.select("#toggle_many_button")
      .on("click", toggle_one_or_many)
    d3.select("#contains_not_button")
      .on("click", create_not_filter)
    d3.select("#clear_pb_button")
      .on("click", clear_contains_builder)

    d3.select("#print_sequences")
      .on("click", show_detailed_view);
    d3.select("#group_sequences")
      .on("click", group_sequences);
    d3.select("#transitionize_sequences")
      .on("click", transitionize_sequences);
    d3.select("#close_detailed_view")
      .on("click", close_detailed_view);

    // d3.selectAll("#close_chart")
    //   .on("click", close_chart);
    
    

    d3.select("#demo_button")
      .on("click", add_action_count_chart);
      


    var charts = [


          barChart()
          .dimension(duration)
          .filter_dimension(dur_filter)
          .dim_name('Duration (hours)')
          .category('time')
          .group(durations)
          .x(d3.scaleLinear()
          .domain([0, 30 ])
          .rangeRound([0, 10])),

          barChart()
          .dimension(hour)
          .filter_dimension(h)
          .dim_name('Hour of the day')
          .category('time')
          .group(hours)
        .x(d3.scaleLinear()
          .domain([0, 24])
          .rangeRound([0, 240])),

        barChart()
          .dimension(start)
          .filter_dimension(start_filter)
          .dim_name('Date')
          .category('time')
          .group(starts)
          .round(d3.timeDay.round)
        .x(d3.scaleTime()
          .domain([new Date(2017, 0, 24), new Date(2017, 3, 3)])
           .rangeRound([0, 225])),
          //.rangeRound([0, 300]))

        barChart()
          .dimension(len)
          .filter_dimension(l)
          .dim_name('# of actions')
          .category('count')
          .group(lens)
          .x(d3.scaleLinear()
          .domain([0, 30])
          .rangeRound([0, 140]))





    ]


    var chart = d3.selectAll(".chart")
                  .data(charts)
    
    var all_charts = d3.selectAll(".chart")
                  .on('click', function(d) {
               
                    update_selected_chart(d3.select(this));
                    
                  });
    var action_hierarchy = {},
        current_level;

        action_hierarchy.general_actions = ['addToCart', 'removeFromCart', 'purchase', 'search', 'pageview']
    current_level = action_hierarchy.general_actions;

    var total_size = all.reduceCount().value(),
        original_size = total_size;
                 
    renderAll();

    var action_i = 0;

    function add_action_count_chart(){

      action_counted = current_level[action_i]

      var chart_div = d3.select('#count_charts').append('div')
                          .attr('class', 'chart')
                          .attr('id', action_counted + '_count_chart')

      chart_div.append('button').attr('type','button').attr('class', 'close').attr('id','close_chart').attr('aria-hidden',true).html('&times;')
      var title_div = chart_div.append('div').attr('class', 'inline-center-center').style("margin-top", '18px')

      title_div.append('div').attr('class', 'title')
          .text('# of ' + action_counted)

      title_div.append('div').attr('class', 'circle').style('background-color', color(action_counted))
      
     
      d3.selectAll("#close_chart")
      .on("click", close_chart);
      

      a_count = seqs.dimension(function(d) {return action_count(d, action_counted)}),
      a_count_filter = seqs.dimension(function(d) {return action_count(d, action_counted)}),
      a_counts = a_count.group(Math.floor)

      charts.push(
        barChart()
          .dimension(a_count)
          .filter_dimension(a_count_filter)
          .dim_name('# of '+ action_counted)
          .category('count')
          .group(a_counts)
          .x(d3.scaleLinear()
          .domain([0, 30])
          .rangeRound([0, 140]))

        )

      // chart = d3.selectAll(".chart")
      //      .data(charts)

      // chart.exit().remove()


      // renderAll();
      rerender_charts()

      action_i++;


    }

    function rerender_charts(){
      chart = d3.selectAll(".chart")
           .data(charts)

      chart.exit().remove()


      renderAll();

    }

    function close_chart(){
      var chart = d3.select(this.parentNode)
      var div = chart.data()[0].div_id()
      console.log('chart-data', div )
      var remove_index;
      for(var i =4; i <charts.length; i++){
        var c = charts[i]
        if (c.div_id()== div)
          remove_index= i;
      }

      charts.splice(remove_index, 1)
      chart.remove()

      rerender_charts()



    }

    //=========================== Node Link =====================================//
    var nl_graph_data = {nodes:[], links: []};
    var nl_margin = {top: 20, right:20, bottom: 20, left: 20},
        nl_svg = d3.select("#node_link").append("svg")
                    .attr("width", 400)
                    .attr("height", 250),
        nl_width = 400 - nl_margin.right - nl_margin.left,
        nl_height = 250 - nl_margin.top - nl_margin.bottom;


    var strokeScale = d3.scaleLinear().domain([0,100]).range([1,6]).clamp(true);



    var nl_graph= cytoscape({
        container: document.querySelector('#cy'),
        boxSelectionEnabled: false,
        minZoom: 0.75,
        maxZoom: 1.25,

        // boxSelectionEnabled: false,
        // autounselectify: true,
        //zoomingEnabled: false,

        style: cytoscape.stylesheet()
          .selector('node')
            .css({
              'content': 'data(action)',
              'width': 18,
              'height': 18,
              'text-halign': 'center',
              'font-size': 12,
              'background-color':'data(color)'
            })
          .selector('edge')
            .css({
              'curve-style': 'bezier',
              'target-arrow-shape': 'triangle',
              'target-arrow-color': 'darkgray',
              'line-color': 'darkgray',
              'font-size': 12,
              'width': 1
              //'label': 'data(value)'
            })
          .selector('.selected')
            .css({
              
              'border-width': 2,
              'border-style': 'solid',
              'border-color': 'black'
            })
          .selector('.invisible')
            .css({
              'opacity': 0
            })
          .selector('.faded')
            .css({
              'opacity': 0.25,
              'text-opacity': 0.25
            })
          .selector('#all_actions')
            .css({
              'background-color': 'white',
              'line-color': 'white'
            })
      });;

      $('#collapse_contains').on('shown.bs.collapse', function () {
        if(node_link_data)
          draw_action_transition_graph(node_link_data)
      });


    function draw_action_transition_graph(node_link_data){

      console.log('NODE LINK DATA', node_link_data)
      nl_graph.zoomingEnabled(true);
      $('#cy').css('height',250);
      $('#cy').css('width', 400);

      nl_graph.elements().remove()


      node_link_data.links.forEach(function(l,i){
        node_link_data.nodes.forEach(function(n){
          l.id = i;
          if (n.id == l.source) l.source = n;
          if (n.id == l.target) l.target = n;

        })

      })

      var nodes = node_link_data.nodes.map(function(n){
        n.color = color(n.action)
        var node ={group:"nodes", data:n}

        if (n.fx){
          n.size = 9;
          n.end = true;
          node.position ={x:n.fx, y:n.fy}
        }else{
         // n.parent ='all_actions'
        }
        nl_graph.add(node)
        return node})

      //f(nodes.length>0) nodes.push({data:{id:'all_actions', color: 'white'}})
      var edges = node_link_data.links.map(function(e){

        

        //e.value = (e.percent >1)? d3.format('.0%')(e.percent/100): 1;
        value = (e.percent >1)? e.percent: 1; 
        var edge = {group:"edges", data:{source: e.source.id, target:e.target.id, value: value}}

        nl_graph.add(edge)

        return edge

        })

      if (edges.length>0){
        nodes.forEach(function(n){

          edges.push({data:{source: 'start', target:n.data.id, value: 0, invisible:true}})
          edges.push({data:{source: n.data.id, target:'exit', value: 0, invisible:true}})
          nl_graph.add({group:"edges", data:{source: 'start', target:n.data.id, value: 0, invisible:true}})
          nl_graph.add({group: "edges", data:{source: n.data.id, target:'exit', value: 0, invisible:true}})
        })
      }


      

      var layout1 = nl_graph.layout({
              name: 'preset'
            })

      layout1.run()

      
      nl_graph.nodes("#all_actions").css({'background-color': 'white',
              'line-color': 'white'})

      // cy.nodes('#start').lock();
      // cy.nodes('#exit').lock();

      nl_graph.nodes().forEach(function(d){
        var data = d.data();

        if (data.size){
          d.css('width', 9)
          d.css('height', 9)
        }

        if (!data.end){
          d.addClass('actions')
        }else{
          d.addClass('end')
        }


      })

      // cy.nodes('.actions').forEach(function(a){
      //   console.log(a.data())
      // })


      var box = {x1:0, x2:0, w:390, h:240}
      var layout  =nl_graph.layout({
              name: 'cola',
              flow: {"axis":"y", "left":"start", "right":"exit", "gap":225, "equality":"true"},
              unconstrIter: 10,
              userConstIter: 20,
              edgeLength:175, 
              fit: true
                 
              

            })



      layout.run()

      layout.on('layoutstop', function(){
        resize()
      })

      

      nl_graph.edges().forEach(function(e){
        var data = e.data()


        e.css('width', strokeScale(data.value))

        if (data.invisible){
          e.addClass('invisible')
        }else{
          e.addClass('visible')
        }
      })


      nl_graph.on('tap', 'node', function(e){



        var node = e.target;
        var neighborhood = node.neighborhood().add(node);

        select_action_node(node.data())

        nl_graph.elements().removeClass('selected')
        nl_graph.nodes().addClass('faded');
        nl_graph.edges('.visible').addClass('faded')
        neighborhood.removeClass('faded');
        node.addClass('selected')
      });

      nl_graph.on('tap', function(e){
        if( e.target === nl_graph ){
          nl_graph.elements().removeClass('faded');
        }
      });


      function resize(){
        
        
        nl_graph.nodes('#start').renderedPosition({x:180, y:20});
      nl_graph.nodes('#exit').renderedPosition({x:180, y:230});

        
      

        nl_graph.nodes('.actions').forEach(function(d){
          var data = d.data();

          var pos = d.renderedPosition()
          if (pos.x<0){
            d.renderedPosition({x:0, y:pos.y})
          }
          if (pos.y<50){
            d.renderedPosition({x:pos.x, y:50})
          }
          if (pos.y>205){
            d.renderedPosition({x:pos.x, y:205})
          }



        
        })

        nl_graph.resize()
        // cy.fit()
        nl_graph.zoomingEnabled(false);
      }
      
      
    }

   
    function dragstarted(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;

    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0);
      // d.fx = null;
      // d.fy = null;
    }

    function reduceInitial_concat() {
        return {
            str: ''
        };
      }

      function reduceAdd_concat(p, v) {
          
          p.str = p.str + start_c + v.general_actions + exit_c;
        
        return p;

      }

      function reduceRemove_concat(p, v) {
        var index = p.str.length - (v.general_actions.length + 2)

        p.str = p.str.substring(0, index)
        
        return p;

      }

    function get_previous_char(str, char){
      var regex = '[^' + char + ']' + '(?=' + char + ')',
          re = new RegExp(regex, 'g'),
          matches = str.match(re);

      

      return matches;
    }

    function get_next_char(str, char){
      var regex = '' + char + '' + '([^' + char + '])' ,
          re = new RegExp(regex, 'g'),
          matches = str.match(re);

      
      new_matches = [];
      if (matches){
        matches.forEach(function(m){
          new_matches.push(m[1]);
        })
      }


      return new_matches;
    }



    function update_action_transition_graph(){
      
      var node_link_data;

      node_link_data = clear_node_link_data();
      draw_action_transition_graph(node_link_data);

      node_link_data = update_node_link_data();
      draw_action_transition_graph(node_link_data);

    }

    function clear_node_link_data(){

      nl_graph_data.nodes = [];
      nl_graph_data.links = [];

      return nl_graph_data;


    }

    function link_exists(links, source, target){

      for (var i=0; i <links.length; i++){
        var l = links[i];
        if((l.source == source) && (l.target == target))
          return l;
      }

      return null;
      

    }

    function update_link_data(action_string, links, pageFunction, reverse){

      var reverse = reverse || false;
      //create edges
      for ( var i =0; i < current_level.length; i++){
        var action = current_level[i],
            char = alphabet[action];

            source = action;

        //console.log('Action: '+ action + ' Char: ' + char);

        var matches = pageFunction(action_string, char);
        
          if (matches){ 
            var total_matches =  matches.length;
            counts = _.countBy(matches, function(char){
              return char;
            });

            for (var c in counts) {
              if (counts.hasOwnProperty(c)) {
                var target = alphabet_rev[c],
                    count = counts[c];
                    value = count*100/total_matches;

                
                if (reverse){
                  var link = link_exists(links, target, source);
                  
                  if(link){
                    link.into_target_percent = value;
                    //link.into_target_count = count;
                  }else{
                    console.log('WEIRD! link not found for reverse')
                  }
                }else{

                  links.push({source:source, target:target, percent:value, count:count});
                  
                }
              }
            }
          }
      }

      return links;
    }
    // var action_string ='';
    // function concatenate_action_strings(){
    //     action_string = all.reduce(reduceAdd_concat, reduceRemove_concat, reduceInitial_concat).value().str;  
    // }

    function update_node_link_data(){
      // var nl_nodes = [],
      //   nl_links = [];
      var action_string;
      

      var nodes =[],
          links = [];

       action_string = all.reduce(reduceAdd_concat, reduceRemove_concat, reduceInitial_concat).value().str;    
      //create nodes
      nodes.push({id:"start", action:"start", group:1, fx: nl_width/2, fy: 0});
      nodes.push({id:"exit", action: "exit", group:0, fx: nl_width/2, fy: nl_height});

      for ( var i =0; i < current_level.length; i++){
        var action = current_level[i];
        nodes.push({id:action, action:action, group:i+2});
      }

      current_level.push("start");

      update_link_data(action_string,links, get_next_char);
      current_level.pop();

      current_level.push("exit")
      update_link_data(action_string,links, get_previous_char, true);
      current_level.pop();


      nl_graph_data.nodes = nodes;
      nl_graph_data.links = links;




      return nl_graph_data;
      
      
    }


    function select_action_node(d){
      var links = nl_graph_data.links,
          before_links =[],
          after_links= [];
      if (selected_action_node){
        selected_action_node.selected = false;
      }
      selected_action_node = d;
      d.selected = true;

      


      update_action_list()
      update_adjacency_chart_data(links);
      update_horizontal_chart(all_matches)
      console.log("Selected action node: ", selected_action_node);


      //draw_action_transition_graph(nl_graph_data);
      
      

    }

    function select_pattern_action_node(d){

      select_action_node(d)

      if (pressed){
        
        if(pattern_data.nodes.length>0){
          //add link to previously added node
          // previous_node_id = selected_pattern_node.id;
          previous_node_id = selected_pattern_node.id;
          add_action_node();
          // current_node_id = selected_pattern_node.id;
          current_node_id = selected_pattern_node.id;
          pattern_data.links.push({"source": previous_node_id, "target": current_node_id, "value": 0.5, "consecutive": consecutive});
          draw_pattern_graph(pattern_data);

        }else{
          add_action_node();
        }

      }


    }
    

    

    var margin_ac = {top: 15, right: 15, bottom: 15, left: 15},
      width_ac = 300 - margin_ac.left - margin_ac.right,
      height_ac = 165 - margin_ac.top - margin_ac.bottom,
      adjacency_chart = d3.select("#adjacency_chart").append('svg').append("g").attr("transform", "translate(" + margin_ac.left + "," + margin_ac.top + ")");




    var center_node = {
          x: (width_ac+8)/2,
          y: (height_ac+8)/2
        }
        



    var bar_width = 10,
        //bar_length = 200; **HORIZONTAL
        bar_length = height_ac,
        bar_len = d3.scaleLinear()
              .rangeRound([0, bar_length]),
        selected_adj_node,
        adj_chart_data = {nodes:[], links:[]};
              

    adjacency_chart.append("svg:defs").selectAll("marker")
          .data(["end"])      // Different link/path types can be defined here
        .enter().append("svg:marker")    // This section adds in the arrows
          .attr("id", String)
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 20)
          .attr("refY", 0)
          .attr("markerWidth", 4)
          .attr("markerHeight", 4)
          .attr("orient", "auto")
          .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "gray");
                      



    function update_adjacency_chart_data(links){

     
      var after_data={type:'after', actions:[], translate:(width_ac - bar_width)},
          before_data ={type:'before', actions:[], translate:0},
          node_data =[before_data, after_data],
          link_data =[],
          x0 = 0,
          total= 0,
          spacing = 30;



      links.forEach(function(l){

        if (l.source.id == selected_action_node.id){
          //after_links.push(l);
          after_data.actions.push({action: l.target.action, group: l.target.group, count:l.count, percent: l.percent});

        }else if (l.target.id == selected_action_node.id){
          //before_links.push(l);
          before_data.actions.push({action: l.source.action, group: l.source.group, count:l.count, percent: l.into_target_percent});
        }
        

      })



      node_data.forEach(function(bar_data){

        var x0 = 0,
          total = 0,
          translate = bar_data.translate,
          data = bar_data.actions;


        data = data.sort(function(a,b) {return b.count - a.count});
        data.forEach(function(d, i){
          //bar coordinates
          d.translate = translate;
          d.x0 =x0, 
          d.x1= x0+= +d.percent;
          total += d.count;

          //node coordinates
          d.x = (bar_data.type == 'before')? width_ac/7: width_ac*(6/7);
          d.y = ((height_ac - (data.length-1)*spacing)/2) + (spacing*i);

          if (bar_data.type == 'before'){
            link_data.push({source:d, target:center_node})
          }else{
            link_data.push({source:center_node, target:d})
          }

        })
        bar_data.total = total;

      })

      adj_chart_data.nodes = node_data;
      adj_chart_data.links = link_data;

      update_adj_chart(adj_chart_data);
      


    }

    function select_adj_node(d){
      if (selected_adj_node){
        selected_adj_node.selected = false;
      }
      selected_adj_node = d;
      d.selected = true;

      console.log('Selected adjacent node', selected_adj_node);
      update_adj_chart(adj_chart_data);

    }


    function update_adj_chart(chart_data){
      d3.select("#tooltip").classed("hidden", true);

     
      var link_data = chart_data.links,
        node_data = chart_data.nodes;
      


      bar_len.domain([0,100]);

         var bars = adjacency_chart
          .selectAll(".adjbar")
              .remove()
              .exit()
              .data(node_data)
              .enter().append("g")
              .attr("class", "adjbar")
              .attr("transform", function (d) { return "translate(" + d.translate + ",0)"; })


              
      var bar= bars.selectAll("rect")
          .remove()
          .exit()
          .data(d =>d.actions)
       
       var bar_enter = bar.enter().append('g')
                        .on("click", select_adj_node);


        bar_enter.append("rect")
              .attr("y", function(d){
                  return bar_len(d.x0);
              })
              .attr("width", function(d){
                  return bar_width;
              })
              .attr("height", function(d){
                  return bar_len(d.x1) - bar_len(d.x0);
              })
              .attr("fill", function(d) {
                //return color(d.group);
                return color(d.action);
              });

        var bar_update = bar_enter.merge(bar);

        bar_update.selectAll('rect')
                .attr('stroke', function(d){ return d.selected? "black": "none"})
                .each(tooltip)


      var links = adjacency_chart.selectAll(".adjlinks")
                  .remove()
                  .exit()
                  .data(link_data)
                  .enter()
                  .append("g")
                  .attr("class", "adjlinks")
 
        links.append("line")
           .attr("class", "link")
           .attr("x1", function(l) {return l.source.x})
           .attr("y1", function(l){return l.source.y})
           .attr("x2", function(l) {return l.target.x})
           .attr("y2", function(l){return l.target.y})
           .attr("marker-end", "url(#end)");

      adjacency_chart.selectAll('.center_node')
                      .remove()
                      .exit()

      var adj_node = adjacency_chart.append("g")
                      .attr("class", "center_node")
                      .attr("transform", "translate(" + center_node.x + "," + center_node.y  + ")");

      adj_node.append("circle")
          //.attr("r",node_radius)
          .attr("r", function(d){
            d = selected_action_node;
            if(d.action == 'start' || d.action == 'exit')
              return end_radius
            else
              return node_radius
          })
          .style("fill", 
            //color(selected_action_node.group)
            color(selected_action_node.action)
          )

      adj_node.append('text')
          .attr('dy', -(node_radius+1))
          .style("font-size", "10px")
          .style("text-anchor", "middle")
          .style('fill', 'black')
          .text(selected_action_node.action)


      

     var adj_nodes = adjacency_chart.selectAll(".adjnodes")
                    .remove()
                    .exit()
                    .data(node_data)
                    .enter().append("g")
                    .attr("class", "adjnodes")

      var node = adj_nodes.selectAll("circle")
                        .remove()
                        .exit()
                        .data(d =>d.actions)
      var node_enter =  node.enter()
                        .append('g')
                        .attr("transform", function(d){return "translate(" + d.x + "," + d.y + ")"})
                        .on("click", select_adj_node)
                        // .on("mouseover", select_adj_node)
                        // .on("mouseout", function(d){return select_adj_node(null);});

      node_enter.append("circle")
            //.attr("r",node_radius)
            .attr("r", function(d){
              if(d.action == 'start' || d.action == 'exit')
                return end_radius
              else
                return node_radius
            })
            .style("fill", function(d){ 
              //return color(d.group)
              return color(d.action);
            })

      node_enter.append('text')
            .attr('dy', function(d){
              if(d.action == 'start' || d.action == 'exit')
                return -(end_radius+1)
              else
                return -(node_radius+1)
            })
            .style("font-size", "10px")
            .style("text-anchor", "middle")
            .style('fill', 'black')
            .text(function(d){return d.action})

      var node_update = node_enter.merge(node);

      node_update.selectAll('circle')
                .attr('stroke', function(d){ return d.selected? "black": "none"})

      


         //drawing chart
   


    }

    function tooltip(d){
      
      if (d.selected){
        var bar_position = d.translate
        var xPosition = (d.translate == 0)? -65 :d.translate + bar_width;
        var yPosition = bar_len(d.x0 +((d.x1-d.x0)/2)) 

        xPosition += margin_ac.left

        console.log('xposition', d.translate)

        var text = d3.format(".1%")(d.percent/100) + ', ' + d3.format(",")(d.count);

        d3.select("#tooltip")
            .style("left", xPosition + "px")
            .style("top", yPosition + "px")
            .select("#value")
            .text(text);

        d3.select("#tooltip").classed("hidden", false);

      }
      
      
    }

    function select_pattern_node(d){
      if (selected_pattern_node){
        selected_pattern_node.selected = false;
      }
      selected_pattern_node = d;
      d.selected = true;



    }

    var node_radius = 8,
        end_radius = 4;

    // ====================== Action List ============== //

    var al_data = []

    var al_svg = d3.select("#action_list").append('svg')
                  .attr('width', 100)
                  .attr('height', 175)




    var al_actions = al_svg.append('g')
                      .attr("transform", "translate(" + 50 + "," + ((node_radius*2)+2) + ")")
    
    update_action_list_data()

    function update_action_list_data(){
      var data = current_level.map(function (action) { return { action: action, id: action}; });
      data.push({action:'start', id:'start'})
      data.push({action:'exit', id:'exit'})
      al_data = data;
    }

    function update_action_list(){

      // var data = current_level.map(function (action) { return { action: action, id: action}; });
      var data = al_data;

      var action = al_actions.selectAll('.action')
                          .remove()
                          .exit()
                          .data(data)
                          
      var action_enter = action.enter().append('g')
                          .attr('class', 'action')
                          .attr("transform", function(d, i){return "translate(" + 0 + "," + (node_radius*3)*i + ")" })
                          .on("click", select_pattern_action_node)

      action_enter.append('circle')
            .attr("r", function(d){
              if(d.action == 'start' || d.action == 'exit')
                return end_radius
              else
                return node_radius
            })
            .attr('fill', function(d){return color(d.action);})

      action_enter.append('text')
          .style('fill', 'black')
          .style("font-size", "10px")
          .style("text-anchor", "middle")
          .attr('dy', 
            node_radius/2 
            //node_radius
            )
          .text(function(d) {return d.action;})

      var action_update = action_enter.merge(action)

      action_update.selectAll('circle')
          .attr('stroke', function(d){ return d.selected? 'black': 'none'})


    }





    // ========================== Pattern Builder ============================== //
    


    var pattern_data = {nodes:[], links: []},
        selected_pattern_node;

    var node_id = 0
    function add_action_node(){

      if (selected_action_node){
        new_node = {
          action: selected_action_node.action,
          id: selected_action_node.id + node_id++,
          pid: 'n' + node_id++
        }
        // if (pattern_data.nodes.length == 0){
        //   pb_width =  pbDiv.node().clientWidth
        //   new_node.fx = pb_width/2;
        //   new_node.fy = 0;
        // }

        select_pattern_node(new_node);
        pattern_data.nodes.push(new_node);
        draw_pattern_graph(pattern_data);
      }
      else
        console.log('Please select node to add!')
    }

    function remove_action_node(d){
      //ONLY WORKS FOR FUNNEL
      if (selected_pattern_node){
        var nodes = pattern_data.nodes,
            links = pattern_data.links,
            idx = nodes.indexOf(selected_pattern_node);

        //assumes nodes and links were added in order
        nodes.splice(idx);

        for(var i=0; i<links.length; i++){
          var l = links[i];
          if (l.source == selected_pattern_node){
            idx = i;
            break;
          }
        }
        //if its not the first node, remove the previous incoming link
        if (idx>0)
          idx = idx-1;


        links.splice(idx);

        console.log('index of remove', idx);
        console.log('new nodes', pattern_data.nodes);

        draw_pattern_graph(pattern_data);
      }else{
        alert('Please select node to remove!');
      }


    }

    function toggle_one_or_many(){


      var many = selected_pattern_node.many;
      
      selected_pattern_node.many = many? !many: true;

      draw_pattern_graph(pattern_data)
      

    }

    function create_not_filter(){
      //toggle_button_color("#contains_not_button")
      pattern_data.not =("not" in pattern_data)? !pattern_data.not : true;
      if($('#apply_funnel_button').is(':disabled'))
        $('#apply_funnel_button').prop('disabled', false);
      else
        $('#apply_funnel_button').prop('disabled', true);
      draw_pattern_graph(pattern_data)
    }

    function clear_contains_builder(){
      pattern_data = {
          nodes: [],
          links: [],
          not: false
      }

      draw_pattern_graph(pattern_data)
    }


    var pressed= false,
        consecutive = false;

    function create_funnel(){
      //toggle_button_color("#create_funnel_button");
      consecutive = false;
      pressed = true;
      // d3.select("#create_funnel_button").text(function(d){return pressed? 'Complete Pattern': 'Add Non-Consecutive Links'});

    }

    function add_link(){
      //toggle_button_color("#add_cons_link_button");
      consecutive = true;
      pressed = true;
      // d3.select("#add_cons_link_button").text(function(d){return pressed? 'Complete Pattern': 'Add Consecutive Links'});

    }

    var any_node = {
        action: null,
        group: null
    }

    function copy_node(node){
      //var node_copy = JSON.parse(JSON.stringify(node))
      var node_copy = {}
      node_copy.action = node.action
      node_copy.value = node.value
      node_copy.id = node.id 
      node_copy.fx = node.x;
      node_copy.fy = node.y;
      //node_copy.selected = false;

      return node_copy
    }

    function copy_link(link){
      var link_copy = {
          'source': link.source.id,
          'target': link.target.id,
          'value': 0.5,
          'consecutive': link.consecutive
      }
      return link_copy

    }

    function apply_funnel(){

      create_contains_filter(true)
    }

    function apply_contains_filter(){
      create_contains_filter(false)
    }



    function create_contains_filter(funnelize){

      reset_filters()

      var nodes = pattern_data.nodes,
          links = pattern_data.links,
          not = ("not" in pattern_data)? pattern_data.not: false;
          regex = '',
          chars= [],
          pattern =[],
          filters = [],
          parent = selected_segment,
          nodes_copy = [],
          links_copy = []
          

      console.log('nodes', nodes)
      console.log('links',links)

      // links.forEach(function(l){
      //   links_copy.push(copy_link(l))
      // })

      if (nodes[0].action != 'start'){
        regex = '.*';
        pattern.push(any_node)
      }

      nodes.forEach(function(n, i){
        nodes_copy.push(copy_node(n))
        var sep,
            c = alphabet[n.action],
            many = n.many | false;
        if (c == exit_c)
          c = '$';
        else if (c == start_c)
          c = '^';

        if( i>0){
          links_copy.push(copy_link(links[i-1]))
        }

        var pattern_node = {
            action: n.action,
            char: c,
            group: n.group,
            many: many
        }
        if( (n.action != 'start') && (n.action != 'exit')){
          pattern.push(pattern_node)
          chars.push(pattern_node.char); 
        }

        c = many? c+'+' : c;
        sep = links[i]? (links[i].consecutive? '': '.*'): (c=='$'? '':'.*')
        if (sep == '.*')
          pattern.push(any_node);
        regex = regex + c + sep;
        console.log('regex', regex);
        
        if (funnelize){

          if (i < (nodes.length-1)){
            var match = all.reduce(reduceAdd,reduceRemove, reduceInitial).value();



            if (match){
              var size = match.count,
                  filter = {},
                  //funnel = {char: chars.slice(), consecutive:consecutive};
                  funnel = chars.slice();

              if (not)
                size = total_size - size;

              if(links[i].consecutive)
                pattern.push(any_node)

              console.log('Regex used for sizing,' , regex)
              selectedFilter.chart = selected_chart;
              selectedFilter.size = size;
              selectedFilter.type = 'contains';
              selectedFilter.char = funnel;
              selectedFilter.regex = regex;
              selectedFilter.not = not;
              selectedFilter.chart = d3.select("#node_link");
              selectedFilter.pattern = pattern;

              selectedFilter.pattern_data = {nodes: nodes_copy.slice(), links:links_copy.slice(), not:not};



              console.log('pattern created', pattern);
              console.log('creating filter:', selectedFilter);

              selectedFilter.div = "action_strings";

              var filter = create_filter(parent);
              parent = filter.children[0];

              if(links[i].consecutive)
                pattern.pop()

            }
          }

        }


      })

      var match = all.reduce(reduceAdd,reduceRemove, reduceInitial).value();

        if (match){
          var size = match.count,
              filter = {},
              //funnel = {char: chars.slice(), consecutive:consecutive};
              funnel = chars.slice();

          if (not)
            size = total_size - size;

          console.log('Regex used for sizing,' , regex)
          selectedFilter.chart = selected_chart;
          selectedFilter.size = size;
          selectedFilter.chart = d3.select("#node_link");
          selectedFilter.type = 'contains';
          selectedFilter.char = funnel;
          selectedFilter.regex = regex;
          selectedFilter.not = not;
          selectedFilter.pattern = pattern;
          selectedFilter.pattern_data = {nodes: nodes_copy.slice(), links:links_copy.slice(), not:not};

          console.log('pattern created', pattern);
          console.log('creating filter:', selectedFilter);

          selectedFilter.div = "action_strings";

          var filter = create_filter(parent);

        }


      function reduceInitial() {
        return {
            count: 0
        };
      }

      function reduceAdd(p, v) {
        if (v.general_actions.match(regex))
          p.count = p.count + 1;
        
        return p;

      }

      function reduceRemove(p, v) {
        if (v.general_actions.match(regex))
          p.count = p.count - 1;
        
        return p;

      }



    }

    function copy_pattern_data(data){
      pattern_data = {nodes:data.nodes.slice(), links:data.links.slice(), not:data.not}
      return pattern_data
    }

    //var contains_not_color = '#54575b'
    var contains_not_color = '#81858c'
    var contains_not_bg_color = '#c5c8cc'

    var pb_graph = cytoscape({
        container: document.querySelector('#pb_graph'),
        boxSelectionEnabled: false,
        maxZoom: 1.25,

        style: cytoscape.stylesheet()
          .selector('node')
            .css({
              'content': 'data(action)',
              'width': 18,
              'height': 18,
              'text-halign': 'center',
              'font-size': 12,
              'background-color':'data(color)'
            })
          .selector('edge')
            .css({
              'curve-style': 'bezier',
              'target-arrow-shape': 'triangle',
              'target-arrow-color': 'darkgray',
              'line-color': 'darkgray',
              'font-size': 12,
              'width': 1
              //'label': 'data(value)'
            })
          .selector('.dotted')
            .css({
              'line-style': 'dashed'
            })
          .selector('.end')
            .css({
              'width': 9,
              'height': 9
            })
          .selector('.many')
            .css({
              'border-width': 5,
              'border-color': 'data(color)',
              'background-color': 'black'
              // 'width': 9,
              // 'height': 9
            })
          .selector('.selected')
            .css({
              
              'border-width': 2,
              'border-style': 'solid',
              'border-color': 'black'
            })
          .selector('.faded')
            .css({
              'opacity': 0.25,
              'text-opacity': 0.25
            })
      });

    function draw_pattern_graph(node_link_data){
      console.log('NODE LINK DATA', node_link_data)
      
      pb_graph.zoomingEnabled(true);

      //var current_width = d3.select('#pb_graph').node().clientWidth,
      var current_width = $('#pb_graph').width()

      $('#pb_graph').css('height', 400);
      $('#pb_graph').css('width', current_width);
      pb_graph.resize()

      pb_graph.elements().remove()
      

      node_link_data.links.forEach(function(l,i){
        node_link_data.nodes.forEach(function(n){
          l.id = i;
          if (n.id == l.source) l.source = n;
          if (n.id == l.target) l.target = n;

        })

      })

      node_link_data.nodes.forEach(function(n){
        n.color = color(n.action)

        var node ={group:"nodes", data:n}

        pb_graph.add(node)
      })

      node_link_data.links.forEach(function(e){


        var value = (e.percent >1)? e.percent: 1; 

        var edge = {group:"edges", data:{source: e.source.id, target:e.target.id, consecutive:e.consecutive}}
        pb_graph.add(edge)

      })



      $('#pb_graph').css('height',400);

      if(node_link_data.not)
        $('#pb_graph').css('background-color',contains_not_bg_color);
      else{
        $('#pb_graph').css('background-color',"");
      }
      
      var layout = pb_graph.layout({
        name: 'dagre'
      })

      layout.run();

      pb_graph.edges().forEach(function(e){
        var data = e.data()

        if(!data.consecutive){
          e.addClass('dotted')
        }
      })

      pb_graph.nodes().forEach(function(n){
        var data = n.data()

        // if (data.type =='many'){
          
        //   n.addClass('many')
        // }

        if(data.many){
          n.addClass('many');
        }
        if((data.action=='start') || (data.action=='exit')){
          n.addClass('end');
        }
      })

      pb_graph.on('tap', 'node', function(e){



        var node = e.target;
        var neighborhood = node.neighborhood().add(node);



        select_pattern_node(node.data())

        pb_graph.elements().removeClass('selected')
        node.addClass('selected')
      });

      pb_graph.zoomingEnabled(false);
    }


    //========================== Detailed View ==================================//
    var patterns = {};
    function remove_duplicates(str){
      return str.replace(/[^\w\s]|(.)(?=\1)/g, "");
    }



    function find_patterns(str, patterns){
      var re = /(.+?)\1+/g;
      if(!patterns){
        patterns = {};
      }
      str = remove_duplicates(str);
      while (m = re.exec(str)){
        var patt = m[1],
            reps = m[0].length/m[1].length;

        if(patterns[patt]){
          patterns[patt].push(reps);
        }
        else{
          patterns[patt] = [reps];
        }


      } 
      return patterns

    }

    function find_all_patterns(){

      var p = all.reduce(reduceAdd, reduceRemove, reduceInitial).value().patterns
      var patts = Object.keys(p).map(function(key){
        return {key:key, value: p[key]};
      })
      patts.sort(function(p1, p2){ return p2.value.length - p1.value.length;})

      return patts

      function reduceInitial() {
        return {
            patterns: {}
        };
      }

      function reduceAdd(p, v) {
          p.patterns = find_patterns(v.general_actions, p.patterns);
        
        return p;

      }

      function reduceRemove(p, v) {
        
        return p;

      }


    }
    var transitionized = false,
        grouped_seqs = false;


    function show_detailed_view(){
      $("#sequences").show()
      print_sequences()
    }

    function close_detailed_view(){
      $("#sequences").hide()
    }

    
    function transitionize_sequences(){
      //toggle_button_color('#transitionize_button')
      transitionized = !transitionized
      print_sequences()
    }

    function group_sequences(){
      //toggle_button_color('#group_button')
      grouped_seqs = !grouped_seqs
      print_sequences()

    }

    function print_sequences(){
      if($("#sequences").is(':visible')){

        if (grouped_seqs){
          var grouped = transitionized? trans_grouped.top(Infinity): strings_grouped.top(Infinity)
          //var grouped = trans_grouped.top(Infinity),
              text ="  #  | sequence" + " <br/>" + "___________"+ " <br/>";

          console.log(grouped)

          grouped.forEach(function(g){
            if(g.value != 0){
              text += ' ' + g.value + "  |  " + g.key + " <br/>"
            }
          })
        }else{
          var dimData = action_strings.top(Infinity)
          var text = "";
          dimData.forEach(function(x){
            var seq = transitionized? remove_duplicates(x.general_actions): x.general_actions;

            text += seq + " <br/>";
          })
        }

        //$("#sequences").show()
        var width = d3.select('#sequences').node().clientWidth
        $("#sequences_text").width(width).height(200)
        $("#sequences_text").html(text)
        $("#sequences_text").css("font-size", "12px");

      }
    }
    //=========================== Builder Views ====================================//
    var active_builder_view = null,
        active_view = null;
    // function update_builder_view(view_id){
    //   view_id = view_id || null;
    //   active_builder_view = view_id;
    //   d3.selectAll(".builder")
    //     .style('display', function(d) {
    //       var id = d3.select(this).attr('id');
    //       if (id != active_builder_view)
    //         return 'none';
    //     });
    // }



     function update_range_builder_view(view_id){

      var id = '.nav-pills a[href="#' + view_id + '"]';
      
      $(id).tab('show')

      // view_id = view_id || null;
      // active_builder_view = view_id;
      // d3.selectAll(".range_builder")
      //   .style('display', function(d) {
      //     var id = d3.select(this).attr('id');
      //     if (id != active_builder_view)
      //       return 'none';
      //   });
    }

    //=========================== Info Views ====================================//

    function update_info_view(view_id){
      view_id = view_id || null;
      active_view = view_id;
      d3.selectAll(".info")
        .style('display', function(d) {
          var id = d3.select(this).attr('id');
          if (id != active_view)
            return 'none';
        });
    }

    //------------ Node view ------------- //

    var activeview;
    var text_object = [];

    function show_node_view(selected){
      var d = selected.data;
      update_info_view("info_view");
      if (d.value == 1){
        // update_info_view("segment_view");
        
        get_segment_info(selected);
      }else if(d.value == 0){
        get_filter_info(selected);
      }else if(d.value == 2){
        get_partition_info(selected);
      }

    }


    function update_text(view, text_format) {

      var selection = view.selectAll('.filterText')
                  .data(text_object)

      selection.enter()
        .append('text')
        .attr('class', 'filterText')
        .attr("dy", function(d,i){ return i+2 +"em";})
        .style("font-size", "10px")
        .style("text-anchor", "left")
        .style('fill', 'black')
        .text(text_format)

      selection.exit().remove();


    }

     var nv_margin = {top: 20, right:10, bottom: 20, left: 10},
      nv_width = 400 - nv_margin.right - nv_margin.left,
      nv_height = 200 - nv_margin.top - nv_margin.bottom;

    // $(document).on('shown.bs.tab', 'a[data-toggle="tab"]', function (e) {
    //     alert('TAB CHANGED');

    // })

     // $("#contains").tabs({
     //         load: function(event, ui) { alert('loaded contains tabs'); 
     //          }
     //        });

    function update_builder_view(o){
      var id = '.nav-tabs a[href="#' + o.type + '"]',
          new_tab = $(id)

      current_tab =  $("ul#operation_types li.active a")

      if (new_tab[0].id != current_tab[0].id){
        $(id).tab('show')
        $(document).on('shown.bs.tab', 'a[data-toggle="tab"]', function (e) {
          show_builder(o);
        })
      }else{
        show_builder(o);
      }


    }


    function show_builder(o){
      console.log('SHOWING BUILDER of ', selected)


      if (o.value != 1){

        if (o.value == 0){
          if (o.type == 'contains'){
            clear_contains_builder()
            pattern_data = o.pattern_data
            console.log('drawing builder for following pattern data', pattern_data)
            var copy = copy_pattern_data(pattern_data)
            draw_pattern_graph(copy) 
              
            
          }if (o.type == 'range'){

            update_range_builder_view("r_filter");
            update_filter_data(o)

          }
        } else {

          update_range_builder_view("r_partition");
          var thresholds = o.thresholds;
          update_partitions_data(thresholds.slice(0, thresholds.length -1))
        }


      }
    }



    //----------- Filter View -------------- //
    var infoLength = 100,
        separation = 40,
        infoRange = [0,infoLength]
        infoScale = d3.scaleLinear().range(infoRange)

    var info_height = 150;

    var rLength = infoLength,
        rRange = [1, rLength]

    var rScale = d3.scaleLinear()
                  .domain([0, original_size])
                  .range(rRange)

    var infoDiv = d3.select('#info_view')

    var nv_svg = infoDiv
                    .append("svg")
                    // .attr("width", nv_width + nv_margin.left + nv_margin.right)
                    // .attr("height", nv_height + nv_margin.top + nv_margin.bottom)
                    //.attr("transform", "translate(" + b_margin.left + "," + b_margin.top + ")");
                    
    var info_view = nv_svg.append("g")
                      .attr("transform", "translate(" + nv_margin.left + "," + nv_margin.top + ")")

    var operation_result_view  = info_view.append("g")
                                .attr('class', "operation_result_view")
                                .attr("transform", "translate(" + 5  + "," + 0 + ")")

    var partition_results_view = info_view.append('g')
                    .attr('class', 'partition_results_view')
                    .attr("transform", "translate(" + 5  + "," + 0 + ")")

    var operation_view = operation_result_view.append('g')
                    .attr('class', 'operation_view')
                    

    var results_view = operation_result_view.append('g')
                    .attr("class", "results_view")
                    .attr("transform", "translate(" + (infoLength+ separation)  + "," + 0 + ")")

    var operation_data = [],
        results_data =[],
        info_data = {
          operation_data: operation_data,
          results_data: results_data,
          partition_data: []
          }
    
    //var size_colors = ['black', 'lightgray', 'white']
    //var size_colors = ['#333333', '#B3B3B3','#E6E6E6']
    var size_colors = ['#333333', '#CCCCCC','#E6E6E6']
    //'#e8eaef'

    function get_results_data(o, show_text){
      var result = o.results,
          max_size = original_size,
          out_size = result.out_size,
          in_size = result.in_size,
          result_data =[],
          size_data = [out_size, in_size, max_size],
          x0 = 0;
      

      size_data.forEach(function(s,i){
        x1 = rScale(s)
        result_data.push({
          x0:x0,
          x1: x1,
          color: size_colors[i]
        })
        x0 = x1;
      })

      result.total_size = max_size
      result.node_data = result_data;

      var size = d3.format(",")(out_size),
          rel = d3.format(".1%")(out_size/in_size),
          abs = d3.format(".1%")(out_size/max_size),
          show = show_text


      var labels = {text: ["# of seqs:", "% relative:", "% total:"], show:show},
          values = {text: [size, rel, abs], show:show}
      
      result.text_data = [labels, values]


      return result
    }

    function format_text(value){
      if (typeof value =='number'){
        return d3.format(",.1f")(value);
      }else
        return dateFormat(value);
    }

    function format_range_text(range){

      return '[' + format_text(range[0]) + ', ' + format_text(range[1]) +']';
    }

    function format_contains_text(char){
      var actions = [];

      if (typeof(char)=='string')
        char = [char]

      
      char.forEach(function(c){
        var a = alphabet_rev[c]
        actions.push(a)
      })
    
      return actions;
    }

    function get_operation_data(o, show_all_text){
      var operation = copy_filter(o),
          operation_data,
          label_text =[],
          value_text =[];

      if (o.type == 'range'){
        infoScale = update_scale(o.range, infoRange)
        operation_data = create_range_filter_data(o, infoScale)
        label_text =['Chart: ', 'Domain: ', 'Filtered: ']
        var value_text = [o.div]
        var domain_range = format_range_text(o.range),
            filtered_range = format_range_text(o.extents)
        
        value_text.push(domain_range)
        if(o.not){

          //filtered_range = '~' + filtered_range
          var pos_ranges = convert_neg_to_pos_ranges(o.range, o.extents)
          pos_ranges.forEach(function(r){
            value_text.push(format_range_text(r))
          })
        }else{
          value_text.push(filtered_range)
        }

      } else if (o.type == 'contains'){
        operation_data = create_contains_filter_data(o, infoLength)

        label_text = o.not? ['Does not Contain: ']: ['Contains: ']
        value_text = format_contains_text(o.char)
        

      }
      var labels = {text: label_text, show:show_all_text},
          values = {text: value_text, show:show_all_text}
      
      operation.text_data = [labels, values]

      operation.node_data = operation_data;

      return operation
    }

    function update_node_info_data(operations, show_all_text){
      var operation_data = [],
          results_data = [],
          show = show_all_text


      if(operations){
        var n = operations.length;


        operations.forEach(function(o,i){
          if ((i == (n-1)) && !show_all_text)
            show_all_text = true;

          var o_data = get_operation_data(o, show_all_text)
          operation_data.push(o_data)

          var r_data = get_results_data(o, show_all_text)
          results_data.push(r_data)

        })

      }

      info_data.operation_data= operation_data
      info_data.results_data = results_data

      return info_data
    }


    function get_filter_info(selected){
      var d = selected.data,
          operation = d.operation,
          chart = operation.chart,
          show_all_text = true;

      // update_selected_chart(chart);
      select_chart(chart)
      info_data.partition_data = [] 
      info_data = update_node_info_data([operation], show_all_text)

      update_node_info_view(info_data)

    }

    function get_partition_info(selected){

      var d = selected.data
          operation = d.operation,
          range = operation.current_range,
          chart = operation.chart,
          operations = operation.results,
          show_all_text = true,
          threshold_ranges = operation.threshold_ranges,
          sep = 40;

      //update_selected_chart(chart);
      select_chart(chart)

      info_data = update_node_info_data(operations, show_all_text)


      infoScale = update_scale(range, infoRange) 
      partition_data = create_range_partition_data(threshold_ranges, infoScale);
      o_data = copy_filter(operation)
      o_data.node_data = partition_data


      var result_ranges =[],
          x0 = 0,
          x1 = 0;

      operations.forEach(function(o){
        x1 = x0 + o.size
        result_ranges.push([x0,x1])
        x0 = x1;  
      })

      var domain_range = [0, x1]

      infoScale = update_scale(domain_range, infoRange)
      result_data = create_range_partition_data(result_ranges, infoScale);
      r_data = copy_filter(operation)
      r_data.node_data = result_data

      info_data.partition_data = [o_data, r_data]

      console.log('info partition data', partition_data)
      console.log('result partition data', result_data)

      update_node_info_view(info_data, sep)
      
    }

    function get_segment_info(selected) {
      var d = selected.data,
          filters = d.filters,
          operations = d.operations,
          operation_data = [],
          results_data = [],
          show_all_text = false

      info_data.partition_data = []
      info_data = update_node_info_data(operations, show_all_text )
      update_node_info_view(info_data)


    }

    function update_node_info_view(data, sep){

      console.log('NODE INFO VIEW DATA', data)
      var sep = sep |1;


      var max_height = (data.operation_data.length +1)*(oWidth+sep),
          svg_height = max_height > info_height? max_height : 150;


      nv_svg.attr('height', svg_height)
      //Results View

      if (data.partition_data.length>0){
        var op_result_view = info_view.select('.operation_result_view')
                             .attr("transform", "translate(" + 0 + "," + oWidth*3 + ")")
      }

      var pData = data.partition_data

      var presult = partition_results_view.selectAll(".presult")
        .remove()
        .exit()
        .data(pData);

      // Enter any new nodes at the parent's previous position.
      var presultEnter = presult.enter().append("g")
          .attr("class", "presult")
          .attr("transform", function(d, i) { return "translate(" + (i*(infoLength+ separation))  + "," + 0 + ")"; })

      presultEnter.append('rect')
          .attr("width", infoLength)
          .attr("height", oWidth)
          .attr("fill", 'none')
          .attr("stroke", "black")

    
      var bar =  presultEnter.selectAll("rect")
                .remove()
                .exit()
                .data(d => d.node_data)
       
      var bar_enter = bar.enter().append('g')

      

      bar_enter.append("rect")
            .attr("x", function(d){
                return d.x0;
            })
            .attr("width", function(d){
                return (d.x1-d.x0);
            })
            .attr("height", oWidth)
            .attr("fill", function(d) {return d.highlighted? "steelblue": "white";})
            .attr("stroke", "black");

      var bar_update = bar_enter.merge(bar);



      

      //Results data

      var rData = data.results_data

      var result = results_view.selectAll(".result")
          .remove()
          .exit()
          .data(rData);

      // Enter any new nodes at the parent's previous position.
      var resultEnter = result.enter().append("g")
          .attr("class", "result")
          .attr("transform", function(d, i) { return "translate(" + 0 + "," + (i*(oWidth + sep))  + ")"; })



      resultEnter.append('rect')
          .attr("width", infoLength)
          .attr("height", oWidth)
          .attr("fill", 'none')
          //.attr("stroke", "black")

      var bar =  resultEnter.selectAll(".size_partition")
                .remove()
                .exit()
                .data(d => d.node_data)
                .attr('class', 'size_partition')
       
      var bar_enter = bar.enter().append('g')
                        .attr("transform", function(d) { return "translate(" + 0 + "," + oWidth/6 + ")"; })


      

      bar_enter.append("rect")
            .attr("x", function(d){
                return d.x0;
            })
            .attr("width", function(d){
                return d.x1-d.x0;
            })
            .attr("height", oWidth*(2/3))
            .attr("fill", function(d) {return d.color;})


      resultEnter.append('g')
        .attr("class", "info_text")


      
      //------------------------OPERATION SIDE ---------------
      oData = data.operation_data
      var operation = operation_view.selectAll(".operation")
          .remove()
          .exit()
          .data(oData);

      // Enter any new nodes at the parent's previous position.
      var operationEnter = operation.enter().append("g")
          .attr("class", "operation")
          .attr("transform", function(d, i) { return "translate(" + 0 + "," + (i*(oWidth + sep)) + ")"; })
          .on("click", select_operation_node)

      var operation_nodes = operationEnter.append('g')
                          .attr("class", function(d) {return d.type})
                          

      operation_nodes.append('rect')
          .attr("width", infoLength)
          .attr("height", oWidth)
          .attr("fill", 'none')
          .attr("stroke", "black")
          


      operationEnter.append('g')
          .attr("class", "info_text")


      //Format Text

      var info_text = operation_result_view.selectAll('.info_text')
                        .attr("transform", "translate(" + 1 + "," + -2 + ")")

      var iText = info_text.selectAll(".iText")
                    .remove()
                    .exit()
                    .data(d => d.text_data)
                    .attr("class", "iText")
                    



      var iTextEnter = iText.enter().append('g')
                        .attr("transform", function(d, i) { return "translate(" + (i*infoLength*0.55) + "," + 0 + ")"; })
                        .attr('class', function(d){return d.show?'show_text': 'no_text'})

      var show_texts = operation_result_view.selectAll(".show_text")

      var text = show_texts.selectAll(".text")
                    .remove()
                    .exit()
                    .data(d => d.text)
                    .attr('class', 'text')

      text.enter()
        .append('text')
        .attr("dy", function(d,i){ return i+3 +"em";})
        .style("font-size", "8px")
        .style("text-anchor", "left")
        .style('fill', 'black')
        .text(function(d) {return d;})

      //range nodes

      var range_nodes = operationEnter.selectAll(".range")

      var range_symbol = range_nodes.append('g')
              .attr("transform", function(d) { return "translate(" + (-oWidth -3) + "," + oWidth/2 + ")"; })

      range_symbol.append('circle')
              .attr('cx', oWidth/2)
              .attr('r', oWidth/2 + 1)
              .attr('fill', function(d){
                if (d.category =='count'){
                  var div = d.div;
                  var action = div.substring(0, div.indexOf('_'))
                  console.log(action)
                  return color(action)
                }else{
                  return 'none'
                }
              })

      range_symbol.append("path")
              .attr('d', function(d){ 

                    var category = d.category;
                    if (category == 'time')
                      return clock_symbol(d);
                    else if (category == 'count')
                      return hash_symbol(d);

                  })
              .attr('fill', 'white')
              .attr('stroke', '#5c616b')

      var bar =  range_nodes.selectAll("rect")
                .remove()
                .exit()
                .data(d => d.node_data)
       
      var bar_enter = bar.enter().append('g')

      

      bar_enter.append("rect")
            .attr("x", function(d){
                return d.x0;
            })
            .attr("width", function(d){
                return (d.x1-d.x0);
            })
            .attr("height", oWidth)
            .attr("fill", function(d) {return d.highlighted? "steelblue": "white";})
            .attr("stroke", "black");

      
      range_nodes.append('text')


      var bar_update = bar_enter.merge(bar);



      // contains nodes

      var contains_nodes = operationEnter.selectAll(".contains")


      contains_nodes.append('rect')
          .attr("width", infoLength)
          .attr("height", oWidth)
          
          .attr("fill", function(d){return d.not? contains_not_color: "white"})

      var circles = contains_nodes.append("g")
                    .attr("transform", function(d) { return "translate(" + oRadius + "," + oWidth/2 + ")"; });

      var circle = circles.selectAll("circle")
                    .remove()
                    .exit()
                    .data(d => d.node_data)

      var circle_enter =  circle.enter().append('g')           
      //var radius = (oWidth/2)-1;

      circle_enter.append('circle')
          .attr('r', oRadius)
          //.attr('cx', function(d,i){return i*oRadius*2})
          .attr('cx', function(d){return d.x})
          .attr('fill', function(d){
            return color(d.action);
            //return d.group? color(d.group): "none"
          })

      circle_enter.append('circle')
          .attr('r', 1)
          .attr('cx', function(d){return d.x})
          .attr('fill', function(d){ return d.many? 'black': 'none'})

    }

           

    var dateFormat = d3.timeFormat("%b %e, %y")
    var tree_info_view = false

    function toggle_operation_manager(){
      if($('#operation_manager').hasClass('open'))
      { 
        $('#toggle_oManager').removeClass('hidden')
        $('#operation_manager').removeClass('col-md-4');
        $('#operation_manager').removeClass('open');
        $('#operation_manager').addClass('hidden');
        $('#tree_view').addClass('col-md-5');
        $('#tree_view').removeClass('col-md-2');
        $('#sequence_attributes').addClass('col-md-7')
        $('#sequence_attributes').removeClass('col-md-6')
      }
      else
      {
        $('#toggle_oManager').addClass('hidden')
        $('#operation_manager').addClass('col-md-4');
        $('#operation_manager').addClass('open');
        $('#operation_manager').removeClass('hidden');
        $('#tree_view').removeClass('col-md-5');
        $('#tree_view').addClass('col-md-2');
        $('#sequence_attributes').addClass('col-md-6')
        $('#sequence_attributes').removeClass('col-md-7')
      }

      resize_windows()

    }

    function toggle_panel(){
      if ($('#show_hide_icon').hasClass('glyphicon-chevron-down')){
        $('#show_hide_icon').removeClass('glyphicon-chevron-down')
        $('#show_hide_icon').addClass('glyphicon-chevron-right')

      }else{

        $('#show_hide_icon').addClass('glyphicon-chevron-down')
        $('#show_hide_icon').removeClass('glyphicon-chevron-right')

      }
      $
    }

    function toggle_tree_info_view(){
      tree_info_view = !tree_info_view
      d3.select('#tree_info_view').style('display', function(d){return tree_info_view? null: 'none'})

      

    }

    function show_contains_builder(){
      //toggle_operation_buttons("#contains_button")
      //update_builder_view("pattern_builder");
      update_action_list()

    }

    function show_range_builder() {
      // toggle_operation_buttons('#range_button')
      // update_builder_view("range_builder");
      show_filter_builder()


    }
    function show_partition_view() {
      //d3.select("#create_partition_view").style("display", "block");
      //update_info_view("create_partition_view");
      //toggle_range_buttons('#build_partition_button')
      //update_range_builder_view("partition_builder");
      update_partitions_data();
    }

    function show_filter_builder(){
      // toggle_range_buttons('#build_filter_button')
      // update_range_builder_view("filter_builder");
      console.log('active range', selected_chart.data()[0].active_range())
      update_filter_data()
    }

    



    function create_range_filter(){

      if (partitions){
        
        var value1 = partitions[2].value,
            value2 = partitions[1].value,
            extents = [value1, value2],
            not = partitions[1].colored? false: true;

        console.log(' Creating range filter with following extents: ' + extents)
        var dimension = selected_chart.data()[0].dimension()
        dimension.filterAll()
        dimension.filterRange(extents);

        var size = all.reduceCount().value()
        var prev_size = selected.data.size;

        size = not? (prev_size - size): size
        //matches = all.reduce(reduceAdd, reduceRemove, reduceInitial).value()
        var selected_chart_data = selected_chart.data()[0];
        selectedFilter.size = size;
        selectedFilter.extents = extents;
        selectedFilter.not = not;
        selectedFilter.chart = selected_chart;
        selectedFilter.div = selected_chart_data.div_id();
        selectedFilter.current_range = selected_chart_data.current_range();
        selectedFilter.range = selected_chart_data.range();
        selectedFilter.category = selected_chart_data.category();
        selectedFilter.type = 'range';

        create_filter()

      }

    }

    function create_not_range_filter(){
      //toggle_button_color('#range_not_button')

      partitions.forEach(function(p){
        p.colored = !p.colored
      })

      update_filter_view()
    }

    // ------------ Filter Builder ------------------- //
    var partition_width = 5,
          partition_height = 25;

    var b_margin = {top: 20, right:15, bottom: 10, left: 15},
      b_width = 400 - b_margin.right - b_margin.left,
      b_height = 130 - b_margin.top - b_margin.bottom,
      b_range= [0, b_width],
      builder_range,
      partitions =[],
      partitions_data =[], 
      range_axis,
      rangeHeight = partition_height/2;

    var range_end_input = d3.selectAll("#range_end_value")
    var range_start_input = d3.selectAll("#range_start_value")




    // range_end_input.on("input", function(){

    //                       set_range_end(this.value)
                
    //                     })

    range_start_input.on("input", function(){
                          set_range_start(this.value)
                
                        })

    function set_range_end(value){
      console.log('going to set the range end')
      console.log(range_end_bar)
      range_end_bar.value = value;
      range_end_bar.x = builder_range(value);
      update_partition_bars(partitions);
      update_filter_view()
      

    }

    function set_range_start(value){
      console.log('going to set the range start')
      
      range_start_bar.value = value;
      range_start_bar.x = builder_range(value);
      update_partition_bars(partitions);
      update_filter_view()
      

    }

    var partition_input = d3.selectAll("#partition_value")
              

        partition_input.on("input", function(){
                set_partition_value(this.value);
                })
        range_end_input.on("input", function(){
                set_range_end(this.value);
                })

     var fb_svg = d3.select("#build_filter_view")
                    .append("svg")
                    .attr("height", b_height)
                    // .attr("width", b_width + b_margin.left + b_margin.right)
                    // .attr("height", b_height + b_margin.top + b_margin.bottom),
                    //.attr("transform", "translate(" + b_margin.left + "," + b_margin.top + ")");
                    
        filter_view = fb_svg.append("g")
                      .attr("transform", "translate(" + b_margin.left + "," + b_margin.top + ")"),

        filter_range = filter_view.append("g")
                      .attr("transform", "translate(" + 0 + "," + b_height*0.35 + ")")
                      .attr("class", "range_bar"),
        ranges = filter_range.append('g')
                      .attr("transform", "translate(" + 0 + "," + -rangeHeight + ")");

    var partitions = []

    function update_filter_data(o){
      partitions = []
      var domain_range = o? o.current_range: null;
      update_builder_range(domain_range)
      
      //o.not

      if (selected_chart && selected_chart.data()[0]){

        active_range = selected_chart? selected_chart.data()[0].active_range(): null;

        

        if (builder_range){
          var extents = o? o.extents: active_range

          var not = o? o.not: $('#range_not_button').is(':checked')? true: false;

          create_filter_data(builder_range, extents, not)

        
        }

        update_filter_view()

      }
      

    } 

    function create_filter_data(scale, extents, not){
      partitions = []
      var max_value = scale.domain()[1],
          value = not? true:false;

  
        partitions.push( {value: max_value , colored: value, x: scale(max_value), hide:true})
        partitions.push( {value: extents[1], id: 'end', colored: !value, x:scale(extents[1])})
        partitions.push( {value: extents[0], id:'start', colored: value, x:scale(extents[0])})

        range_end_bar= partitions[1]
        range_end_input.property("value", range_end_bar.value)
        range_start_bar= partitions[2]
        range_start_input.property("value", range_start_bar.value)
    }
    


    function update_filter_view(){
      



      get_range_ends_data()

      var end = ranges.selectAll('.end')
                .remove()
                .exit()
          
    

      var end = ranges.selectAll('.end')
                .remove()
                .exit()
                .data(rangeEnds)

      end.enter().append('rect')
              .attr('class', 'end')
              .attr('x', function(d){return d;})
              .attr('width', end_len)
              .attr('height', rangeHeight)
              .attr('fill', 'darkgray')
              .on('click', toggle_builder_range)
        
      data = partitions




      // var dimension = selected_chart.data()[0].dimension(),
      //     extents = [data[2].value, data[1].value]

      // dimension.filterRange(extents);

      

      var range = ranges.selectAll('.range')
                    .remove()
                    .exit()
                    .data(data)
      var range_enter = range.enter().append('g')
                    .attr('class', 'range')

      range_enter.append('rect')
          .attr('width', function(d) {return d.x})
          .attr('height', rangeHeight)
          .attr('stroke', 'black')
          .attr('fill', function(d){return d.colored? 'steelblue': 'white'})

      var range_update = range_enter.merge(range)

      range_update.selectAll('rect')
          .attr('width', function(d){return d.x})

      update_partition_bars(partitions)

      filter_range.call(range_axis);

      
    }

    


    //------------ Partition view ------- //

    var builderDiv = d3.select("#info_view")

    var b_svg = d3.select("#create_partition_view")
                    .append("svg")
                    .attr("height", b_height)
                    // .attr("width", b_width + b_margin.left + b_margin.right)
                    // .attr("height", b_height + b_margin.top + b_margin.bottom)
                    //.attr("transform", "translate(" + b_margin.left + "," + b_margin.top + ")");
                    
        partition_view = b_svg.append("g")
                      .attr("transform", "translate(" + b_margin.left + "," + -b_margin.top/3 + ")");


    var selected_partition_bar,
        range_end_bar,
        range_start_bar,
        barId= 1,
        range_bar = partition_view.append("g")
          .attr("transform", "translate(" + 0 + "," + b_height/2 +")")
          .attr("class", "range_bar")

        range_bar_axis = range_bar.append("g")
              .attr("class", "axis"),

        partitions = [];

    
    // var partition_width = 4,
    //       partition_height = 30;


    


    

    function set_partition_value(value){
      if (selected_partition_bar){
        console.log('selected partition bar', selected_partition_bar)
        selected_partition_bar.value = value;
        selected_partition_bar.x = builder_range(value);
        update_partition_bars(partitions);
        update_filter_view()
      }else {
        alert('Select partition bar first');
      }

    }
    function add_partition_bar(x_location){
      x_location = x_location || 0;
      //artitions.forEach(function(p){p.selected = false;})
      var new_partition = {'id': barId++, 'x': x_location, 'value': builder_range.invert(x_location)}
      select_partition_bar(new_partition);
      partitions.push(new_partition);
      update_partition_bars(partitions);

    }

    function remove_partition_bar(){
      var remove_index;

      console.log('the selected partition', selected_partition_bar)

      for(var i = 0; i < partitions.length; i++){
        var p = partitions[i];
        if (p.id == selected_partition_bar.id)
          remove_index = i;
      }

      if (remove_index > -1){
        partitions.splice(remove_index,1);
        update_partition_bars(partitions);
      }else {
        alert('Please select partition bar to remove')
      }

     
      $('#removePartition_button').prop('disabled', true);
      partition_input.property("value","")


    }

    function select_partition_bar(d){
      $('#removePartition_button').prop('disabled', false);

      if (selected_partition_bar)
          selected_partition_bar.selected = false;
        selected_partition_bar = d;
        d.selected = true;
        //partition_input.attr('value', selected_partition_bar.value);
        partition_input.property("value", selected_partition_bar.value)
        update_partition_bars(partitions);
        partition_input.property("value", selected_partition_bar.value )
    }

    function update_partition_bars(data) {


      d3.selectAll(".partition").remove(); 

      var range_bars = d3.selectAll('.range_bar')
      var range_partition = range_bars.selectAll('g.partition')
                                .data(data)
                                .enter()
                                .append('g')
                                .attr('class', 'partition')
                                // .attr("transform", function(d) { return "translate(" + d.x + "," + 0 + ")"; })
                                .call(d3.drag()
                                  .on("start", dragstarted)
                                  .on("drag", dragged)
                                  .on("end", dragended));

      range_partition.append('g')
          .attr('class', function(d){return d.hide? 'hidden': 'visible'})

      visible_partition = range_bars.selectAll('.visible')
      

      visible_partition.append('rect')
      .attr('class', 'partition')
      .attr('width', partition_width)
      .attr('height', partition_height)
      .attr('x', function(d){return d.x})
      .attr('y', -(partition_height/2))
      .attr('stroke', function(d) { return d.selected? 'black' : 'none' })
      .on('click', select_partition_bar)
      
      visible_partition.append('text')
        .attr("dy", ".15em")
        .attr("y", function(d) { return -(partition_height/2)-3; })
        .attr('x', function(d){return d.x + 2})
        .style("font-size", "10px")
        .style("fill", "black")
        .style("text-anchor", "middle")
        .text(function(d) { 
            var value = builder_range.invert(d.x);
            return format_text(value)
            // if (typeof value =='number'){
            //   //return Math.floor(value);
            //   return d3.format(",.1f")(value);
            // }else
            //   return dateFormat(value);

          })

      function dragstarted(d) {
        d3.select(this).raise().classed("active", true);
      }

      function dragged(d) {
        if (!d.selected){
          select_partition_bar(d);
        }
        var event = d3.event.x;
        var x_loc = event;
        if (event < 0)
          x_loc = 0;
        else if (event > b_width)
          x_loc = b_width;

        if (typeof builder_range.domain()[0] == 'number'){
          x_loc = builder_range(Math.round(builder_range.invert(x_loc)));
        }

        d3.select(this).select("rect").attr("x", function(d)  {return d.x = x_loc;});
        d3.select(this).select("text")
            .text(function(d) {
              d.value = builder_range.invert(d.x)
              return format_text(d.value)
              // if (typeof d.value =='number')
              //   return Math.floor(d.value);
              // else
              //   return dateFormat(d.value);
            })
            .attr("x", function(d)  {return d.x = x_loc;});

         
         update_filter_view()
         range_start_input.property("value", range_start_bar.value)
         range_end_input.property("value", range_end_bar.value)
         partition_input.property("value", selected_partition_bar.value);
      }

      function dragended(d) {
        d3.select(this).classed("active", false);
      }

    }


    function select_operation_node(o){
      update_selected_chart(o.chart)
      update_builder_view(o)
    }
    var initialRange = false;
    var fullRange = true,
        rangeEnds = [],
        end_len = 15;

    function update_to_full_range(){
      var range = selected_chart.data()[0].range()
      fullRange= true
      update_builder_range(range)
      var not = $('#range_not_button').is(':checked')? true: false
      create_filter_data(builder_range, [partitions[2].value, partitions[1].value], not )
      update_filter_view()

    }

    function update_to_current_range(){
      fullRange = false
      var range = selected_chart.data()[0].current_range()
      update_builder_range(range)
      get_range_ends_data()

      var not = $('#range_not_button').is(':checked')? true: false
      create_filter_data(builder_range, [partitions[2].value, partitions[1].value], not )
      update_filter_view()

    }


    function toggle_builder_range(){

      fullRange = !fullRange
      var full_range = selected_chart.data()[0].range()
      var current_range = selected_chart.data()[0].current_range()

      if (full_range[0]==current_range[0] && full_range[1]==current_range[1]){
        fullRange = true;
      }
      
      if (fullRange){
        range = full_range
      }
      else{
        range = current_range

      }

      update_builder_range(range)
      get_range_ends_data()
      var not = $('#range_not_button').is(':checked')? true: false
      create_filter_data(builder_range, [partitions[2].value, partitions[1].value], not )
      update_filter_view()
      


    }

    function get_range_ends_data(){
      check_range()
      rangeEnds = [];
      var full_range = selected_chart.data()[0].range()
      var current_range = selected_chart.data()[0].current_range()
      if (!fullRange){
        if (typeof(full_range[0]) == 'number'){
          if (full_range[0]!=current_range[0]){
            rangeEnds.push(-end_len)
          }
          if(full_range[1]!=current_range[1]){
            rangeEnds.push(builder_range.range()[1])
          }

        }else{
          if (full_range[0].getTime()!=current_range[0].getTime()){
            rangeEnds.push(-end_len)
          }
          if (full_range[1].getTime()!=current_range[1].getTime()){
            rangeEnds.push(builder_range.range()[1])
          }
        }

      }
    }

   function check_range(){
      var full_range = selected_chart.data()[0].range()
      var current_range = selected_chart.data()[0].current_range()

      if (typeof(full_range[0]) == 'number'){
        if (full_range[0]==current_range[0] && full_range[1]==current_range[1]){
          fullRange = true;
        }

      }else{
        if (full_range[0].getTime()==current_range[0].getTime() && full_range[1].getTime()==current_range[1].getTime()){
          fullRange = true;
        }
      }

    }


    function update_builder_range(domain_range){
      if (selected_chart && selected_chart.data()[0]){

       //selected_chart.call(selected_chart.data()[0]);
       //var current_range = domain_range? domain_range : selected_chart.data()[0].range();
       var current_range = domain_range? domain_range : selected_chart.data()[0].current_range();




        if (current_range){

          builder_range = update_scale(current_range, b_range)

          

          range_axis = d3.axisBottom(builder_range)
                      .ticks(5) 
          return builder_range
        }

      }

      return null;

    }

    // function update_partitions_data(thresholds){
    //   partitions = []
      

    //   var current_range = selected_chart.data()[0].current_range();


    //   update_builder_range(current_range)
    //   var thresholds = thresholds? thresholds: [builder_range.invert(b_width/3), builder_range.invert(b_width*2/3)]

    //   if (builder_range){
    //     thresholds.forEach(function(p){
    //       add_partition_bar(builder_range(p))
    //     })
    //   }

      

    // } 
    

    function update_partition_view(thresholds){

      partitions =[]

      partitions_data.forEach(function(p){
              add_partition_bar(builder_range(p))
            })

    }



    function update_partitions_data(thresholds){

     //render selected chart
      partitions_data = []

     if (selected_chart && selected_chart.data()[0]){

       //selected_chart.call(selected_chart.data()[0]);
       var current_range = selected_chart.data()[0].current_range();


        if (current_range){

          update_builder_range(current_range)

          range_bar_axis.call(range_axis);


          if (builder_range){
            partitions_data = thresholds? thresholds: [builder_range.invert(b_width/3), builder_range.invert(b_width*2/3)]
            
            update_partition_view()
          }


          // partitions =[];

          // var thresholds = thresholds? thresholds: [builder_range.invert(b_width/3), builder_range.invert(b_width*2/3)]

          // if (builder_range){
          //   thresholds.forEach(function(p){
          //     add_partition_bar(builder_range(p))
          //   })
          // }
          
          



        }

     }

    }

    //----------- end of partition view ----------//

    var selected_leftover_bar;

    function update_selected_leftover(div){

      if (selected_leftover_bar)
        selected_leftover_bar.style("stroke", 'none' );
      selected_leftover_bar = div;
      selected_leftover_bar.style("stroke", "black" );
    }

    function update_selected_chart(div) {


      fullRange = initialRange;

      select_chart(div)
      if( $("#build_filter_view").is(':visible')){
        update_filter_data()
        $('#range_not_button').prop('checked', false);
      }
      else
        update_partitions_data()

    }

    function select_chart(div){
      if (selected_chart)
        selected_chart.style("background-color", "white" );
      selected_chart = div;
      selected_chart.style("background-color", "lightyellow" );
    }

    function render(method) {
      d3.select(this).call(method);
    }

    function renderAll() {
      chart.each(render);
      
    }


    window.filter = filters => {
      filters.forEach((d, i) => { charts[i].filter(d); });
      renderAll();
    };

    window.reset = function(i) {
      charts[i].filter(null);
      selectedFilter={};
      renderAll();
    };


    function get_x_limit(groups, yScale) {

      for (var i= groups.length -1 ; i >= 0 ; i--){
        var grp = groups[i];
        var pixels = yScale(0) - yScale(grp.value);

        if (pixels > 1){
          var x_domain_max;
          if (i == groups.length -1)
            x_domain_max = null;
          else
            x_domain_max = grp.key + 2;
          break;
        }

      }

      return x_domain_max;
    }
    
    function reduce_leftover_count(x_max, groups){
      var leftover_count = 0;

      if (x_max){
        x_max = x_max - 1;
        var idx = groups.length-1;
        grp = groups[idx];

        while (grp.key > x_max){
          leftover_count = leftover_count + grp.value
          idx = idx - 1;
          grp = groups[idx]; 
        }

        return leftover_count;

      } 

      return 0;
    }

  function get_current_range(groups){
    var idx = 0,
        n = groups.length,
        grp = groups[idx];

    while (grp.value == 0 && idx < (n-1)){
      //x_min = grp.key;
      idx = idx+1;
      grp = groups[idx];
    }
    var min = grp? grp.key : groups[0].key;



    var idx = n-1;
        grp2 = groups[idx];

    while (idx > 0 && grp2.value==0){
      // x_max = grp.key;
      idx = idx - 1;
      grp2 = groups[idx]; 
    }
    var max = grp2? grp2.key: groups[0].key;
    return [min, max];
  }

  function add_one(range){
    var range_max = range[1]
    if (typeof(range_max) == 'number'){
      range_max = range_max +1;
    }else{
      newDate = new Date(range_max)
      newDate.setDate(newDate.getDate() + 1); 

      range_max = newDate
    }

    return [range[0], range_max]
  }

  var max_id;

  function barChart() {
      if (!barChart.id) barChart.id = 0;

      var margin = {top: 10, right: 13, bottom: 35, left: 55},
          x,
          y = d3.scaleLinear().range([100, 0]),
          id = barChart.id++,
          axis = d3.axisBottom(),
          axisY = d3.axisLeft(),
          brush = d3.brushX(),
          x_domain_max,
          x_max,
          x_min,
          div_id,
          brushDirty,
          leftover_count,
          dim_name,
          active_range,
          category,
          range,
          current_range,
          dimension,
          filter_dimension,
          group,
          round;
      
      max_id = id;

      function chart(div) {
        var width = x.range()[1],
           height = y.range()[0];

        brush.extent([[0,0], [width, height]]);
        

        div.each(function() {
          var div = d3.select(this),
              g = div.select("g");

          // Create the skeletal chart.
          if (g.empty()) {

            
            
            y.domain([0, group.top(1)[0].value]);

            x_domain_max = get_x_limit(group.all(), y);
            x_max = group.all()[group.all().length-1].key;
            x_min = group.all()[0].key;
            range = add_one([x_min,x_max]);

      
            if (x_domain_max){
              x.domain([x.domain()[0], x_domain_max]);
              x.range([0, x_domain_max*10])

              width = x.range()[1];
              brush.extent([[0,0], [width, height]]);
              margin.right = 30;
              
              if (x_domain_max < 5)
                axis.ticks(x_domain_max);
              
              axis.scale(x);
            }
            


            //remove if change date chart range back to 300
            if (typeof(x_min) != 'number'){
              axis.ticks(4)
              axis.scale(x)

            }

            div.select(".title").append("a")
                .attr("href", "javascript:reset(" + id + ")")
                .attr("class", "reset")
                .text("reset")
                .style("display", "none");



            g = div.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            

            leftover_x = width + margin.right - 18
            var leftover_bar = g.append('g')
                                .attr('transform','translate('+ 0 + ",0)")
            leftover_bar.append("rect")
                    .attr("class", "leftovers")
                    .attr("id", "leftovers")
                    .attr('x', leftover_x)
                    // .attr("y", height - leftover_height)
                    // .attr("height", leftover_height)
                    .attr("width", 9)
                    .on("click", function(d) {

                      update_selected_chart(div);
                      update_selected_leftover(d3.select(this))

                      var extents = [x_domain_max, x_max+1];
  
                      active_range= extents;
                      update_filter_data();
                    })
            leftover_bar.append("text")
              .attr("class", "leftover_text")
              .attr("y", height+2)
              .attr("x", leftover_x + 1)
              .attr("dy", "1em")
              .style("text-anchor", "left")
              .style("font-size", "10px")
              .style("fill","black")
              .text(function(d) { return x_domain_max? ">" : "";});


            g.append("clipPath")
                .attr("id", "clip-" + id)
              .append("rect")
                .attr("width", width)
                .attr("height", height);

            

            g.selectAll(".bar")
                .data(["background", "foreground"])
              .enter().append("path")
                .attr("class", function(d) {return d + " bar"; })
                .datum(group.all());

            g.selectAll(".foreground.bar")
                .attr("clip-path", "url(#clip-" + id + ")");

            g.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(0," + height + ")")
                .call(axis);


            g.append("g")
                .attr("class", "axisY")
                .call(axisY);
            //set up y axis title
            g.append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 0 - margin.left)
              .attr("x",0 - (height / 2))
              .attr("dy", "1em")
              .style("text-anchor", "middle")
              .style("font-size", "10px")
              .style("fill","black")
              .text("# of Sequences"); 

            //set up x axis title
            g.append("text")             
              .attr("transform",
                    "translate(" + (width/2) + " ," + 
                                   (height + margin.top + 20) + ")")
              .style("font-size", "10px")
              .style("text-anchor", "middle")
              .style("fill","black")
              .text(dim_name);


            //Initialize the brush component with pretty resize handles.
            var gBrush = g.append("g").attr("class", "brush").call(brush);

            gBrush.selectAll('.handle--custom')
              .data([{ type: 'w' }, { type: 'e' }])
              .enter().append('path')
                .attr('class', 'brush-handle')
                .attr('cursor', 'ew-resize')
                .attr('d', resizePath)
                .style('display', 'none');
          }

          

          if (brushDirty !== false) {
            const filterVal = brushDirty;
            brushDirty = false;

            div.select('.title a').style('display', d3.brushSelection(div) ? null : 'none');

            if (!filterVal) {
              g.call(brush);

              g.selectAll(`#clip-${id} rect`)
                .attr('x', 0)
                .attr('width', width);

              g.selectAll('.brush-handle').style('display', 'none');
              renderAll();
            } else {
              const range = filterVal.map(x);
              brush.move(gBrush, range);
            }
          }





          var leftover_count = reduce_leftover_count(x_domain_max, group.all());
          

          current_range = add_one(get_current_range(group.all()));
          div_id = div.attr("id");


          if (new_selection){

              y_max = group.top(1)[0].value;
              new_y_max = leftover_count > y_max ? leftover_count : y_max;

              y.domain([0, new_y_max]);
              t1 = g.transition().duration(1000);
              
              t1.selectAll(".bar").attr("d", barPath);
              t1.selectAll(".axisY").call(axisY);

              if (x_domain_max){
                t1.select('#leftovers')
                  .attr("height", height - y(leftover_count))
                  .attr("y", y(leftover_count))

              }

            } else {

              g.selectAll(".bar").attr("d", barPath);
              if (x_domain_max){
                g.select('#leftovers')
                  .attr("height", height - y(leftover_count))
                  .attr("y", y(leftover_count));
              }
              
            }
            


          
        });

        function leftoverPath(leftover_height){
          return "M" + (width+18) + "," + height + "V" + y(leftover_height) + "h" + 9 + "V" + height;
        }

        function barPath(groups) {
          var path = [],
              i = -1,
              n = groups.length,
              d;


          // if (typeof x.domain()[1] == "number"){
          //   n_groups = x.domain()[1];
          //   bar_width = Math.floor(x.range()[1]/n_groups) -0.05 
          // }
          // else
          //   bar_width = 8;
          //   //n_groups = n;
          // ;
          bar_width = 9;
          while (++i < n) {
            d = groups[i];
            //path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
            if (x_domain_max){
              if (d.key < x_domain_max)
                path.push("M", x(d.key), ",", height, "V", y(d.value), "h" + bar_width + "V", height);
            } else {
              path.push("M", x(d.key), ",", height, "V", y(d.value), "h" + bar_width + "V", height);
            }
          }

          return path.join("");
        }

        function resizePath(d) {
          var e = +(d == "e"),
              x = e ? 1 : -1,
              y = height / 3;
          return "M" + (.5 * x) + "," + y
              + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
              + "V" + (2 * y - 6)
              + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
              + "Z"
              + "M" + (2.5 * x) + "," + (y + 8)
              + "V" + (2 * y - 8)
              + "M" + (4.5 * x) + "," + (y + 8)
              + "V" + (2 * y - 8);
        }
      }

      brush.on("start.chart", function() {
        var div = d3.select(this.parentNode.parentNode.parentNode);
        update_selected_chart(div);
        //reset_filters(id);
        div.select(".title a").style("display", null);
        selectedDiv = div.attr('id');
      });

      brush.on('brush.chart', function () {
        const g = d3.select(this.parentNode);
        const brushRange = d3.event.selection || d3.brushSelection(this); // attempt to read brush range
        const xRange = x && x.range(); // attempt to read range from x scale
        let activeRange = brushRange || xRange; // default to x range if no brush range available
        
        const hasRange = activeRange &&
          activeRange.length === 2 &&
          !isNaN(activeRange[0]) &&
          !isNaN(activeRange[1]);

        if (!hasRange) return; // quit early if we don't have a valid range

        // calculate current brush extents using x scale
        let extents = activeRange.map(x.invert);


        // if rounding fn supplied, then snap to rounded extents
        // and move brush rect to reflect rounded range bounds if it was set by user interaction
        if (round) {
          extents = extents.map(round);
          activeRange = extents.map(x);

          if (
            d3.event.sourceEvent &&
            d3.event.sourceEvent.type === 'mousemove'
          ) {
            d3.select(this).call(brush.move, activeRange);
          }
        }

        // move brush handles to start and end of range
        g.selectAll('.brush-handle')
          .style('display', null)
          .attr('transform', (d, i) => `translate(${activeRange[i]}, 0)`);

        // resize sliding window to reflect updated range
        c = g.select(`#clip-${id} rect`)
          .attr('x', activeRange[0])
          .attr('width', activeRange[1] - activeRange[0]);



        // filter the active dimension to the range extents

    
        dimension.filterRange(extents);
        
        active_range = extents;
        update_filter_data()



        // re-render the other charts accordingly
        renderAll();
      });


       brush.on('end.chart', function () {
        // reset corresponding filter if the brush selection was cleared
        // (e.g. user "clicked off" the active range)
        console.log('all ids but', id)
        reset_filters(id);
        if (!d3.brushSelection(this)) {
          reset(id);
          selectedFilter = {};

          active_range= current_range;
          update_filter_data()
        }

      });

      chart.margin = function(_) {
        if (!arguments.length) return margin;
        margin = _;
        return chart;
      };

      chart.x = function(_) {
        if (!arguments.length) return x;
        x = _;
        axis.scale(x);
        axisY.scale(y).ticks(6);
        return chart;
      };

      chart.y = function(_) {
        if (!arguments.length) return y;
        y = _;
        return chart;
      };
      
      chart.dim_name = function(_) {
        if (!arguments.length) return dim_name;
        dim_name = _;
        return chart;
      };

      chart.category = function(_) {
        if (!arguments.length) return category;
        category = _;
        return chart;
      };

      chart.id = id;
      //chart.div_id = div_id;

      chart.dimension = function(_) {
        if (!arguments.length) return dimension;
        dimension = _;
        return chart;
      };

      chart.filter_dimension = function(_) {
        if (!arguments.length) return filter_dimension;
        filter_dimension = _;
        return chart;
      };

      chart.filter = _ => {
        if (!_) dimension.filterAll();
        brushDirty = _;
        return chart;
      };

      chart.group = function(_) {
        if (!arguments.length) return group;
        group = _;
        return chart;
      };

      chart.round = function(_) {
        if (!arguments.length) return round;
        round = _;
        return chart;
      };

      chart.gBrush = () => gBrush;

      chart.range = () => range;

      chart.div_id = () => div_id;
      

      chart.current_range = function(_) {
        if (!arguments.length) return current_range;
        current_range = _;
        return chart;
      };

      chart.active_range = function(_) {
        if (!active_range)
          active_range = current_range
        if (!arguments.length) return active_range;
        active_range = _;
        return chart;
      };



      return chart;
    }
     

    //});






  var data = [];                        //Initialize empty array
  for (var i = 0; i < 1000; i++) {           //Loop 25 times
      //var newNumber = Math.random() * 30;
      var newNumber = Math.round(Math.random() * 100);  //New random number (0-30)
      data.push(newNumber);             //Add new number to array
  }


  function group_count(d, thresholds) {
    
    thresholds = thresholds || [10, 2, 1, 0];

    var index = 0;
    t = thresholds[index];
    while (d < t){
      index = index + 1;
      t = thresholds[index];
    }
    
    return thresholds[index];
  }


  var margin = {top: 20, right:20, bottom: 20, left: 20},
      width = 400 - margin.right - margin.left,
      height = 750 - margin.top - margin.bottom;

  var RECT_W_max = 100,
      RECT_W_min = 1,
      RECT_H = 20,
      DEPTH = 35;


  var data0 = [
      { "name": "Root", "parent": "null", "visible":1, "value":-1},
      { "name" : "Segment A", "parent":"Root", "value":1, "visible":1}
      ];

  total_size = all.reduceCount().value();
  data0[1].size = total_size;
  original_size = data0[1].size;

  wScale = d3.scaleLinear().domain([0,total_size]).range([RECT_W_min, RECT_W_max]);

  //var data = JSON.parse(JSON.stringify(original_data));
  original_data = JSON.stringify(data0)
  data = JSON.parse(original_data)

  var treeData = [];

  unflatten(treeData, data);




  // ************** Generate the tree diagram  *****************
  //var buttons = d3.select("#buttons")


      
  var i = 0,
      //duration = 750,
      duration = 0,
      root;

  var tree = d3.tree()
        .size([width, height]);

  var treeDiv = d3.select('#tree')

  var t_svg = d3.select('#tree').append("svg")
            .attr('width', "100%")
            .attr('height', "100%")

      // .attr("width", width + margin.right + margin.left)
      // .attr("height", height + margin.top + margin.bottom)
     //  .attr("preserveAspectRatio", "xMinYMin meet")
     //  .attr("viewBox", "0 0 600 400")
     // //class to make it responsive
     //  .classed("svg-content-responsive", true)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");





  var selected,
      selected_segment,
      selected_chart,
      //current_range,
      selected_action_node;



  size = 1000;
  root = d3.hierarchy(treeData[0], function(d) { return d.children; })
  root.x0 = height / 2;
  root.y0 = 0;





  
  function resize_windows(){

    resize_tree()
    resize_builder()
    resize_sequence_details()
  }

  function resize_sequence_details(){
    var width = d3.select('#sequences').node().clientWidth - 40;
    $("#sequences_text").width(width)
  }
  function resize_builder(){
      var width = builderDiv.node().clientWidth

      b_width = width - b_margin.right - b_margin.left

      b_range = [0,b_width]

      update_builder_range()

       p_width = (width< 235)? width: width-150
      //p_width = (0.25*width <100)? width-110: 0.75*width

      fb_svg
          .attr("width", width)

      b_svg
          .attr("width", width)

      nv_svg
          .attr("width", width)


      $('#pb_graph').css('width', p_width).css('height', 400);

      // pb_svg
      //     .attr("width", p_width)


      

      infoLength = width*(3/7),
      separation = width/7 - 20,
      translation = infoLength + separation;

      infoRange = [0,infoLength]
      rScale.range([1,infoLength])

      d3.selectAll('.results_view').remove()

      results_view = operation_result_view.append('g')
                    .attr("class", "results_view")
                    .attr("transform", "translate(" + translation  + "," + 0 + ")")

      show_node_view(selected)
      draw_pattern_graph(pattern_data)

      if( $("#build_filter_view").is(':visible'))
        update_filter_data()
      else
        update_partition_view()
      
    }


  d3.select(self.frameElement).style("height", "500px");


  //-------------------- FUNCTIONS ---------------------

    function unflatten(treeData, data) {
        
        var dataMap = data.reduce(function(map, node) {
            map[node.name] = node;
            return map;
        }, {});

        data.forEach(function(node) {
         // add to parent
         var parent = dataMap[node.parent];
         if (parent) {
          // create child array if it doesn't exist
          (parent.children || (parent.children = []))
           // add node to child array
           .push(node);
         } else {
          // parent is null or missing
          treeData.push(node);
         }
        });
    }

    
    function resize_tree(){
      var width = treeDiv.node().clientWidth,
          height = 2000

      t_svg.attr("width", width)

      tree.size([width-(oLength/2), height]);

      root.x0 = height / 2;
      root.y0 = 0;

      update(root)
    }


    function update(source) {


      

      //console.log('UPDATING');
      // Compute the new tree layout.
      var treeData = tree(root);
      var nodes = treeData.descendants(),
          links = treeData.descendants().slice(1);


      // Normalize for fixed-depth. Each layer is same distant apart
      nodes.forEach(function(d) { d.y = d.depth * DEPTH; });

      // Update the nodes…
      var node = t_svg.selectAll("g.node")
          .data(nodes, function(d) {return d.id || (d.id = ++i); });

      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("g")
          .attr("class", "node")
          .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
          //.on("dblclick", hide_children)
          .on("click", select_node)
          //.on("dblclick", filter_partition);

          
      nodeEnter.append('g')
              .attr("class", function(d) {
                if (d.value ==1) return "segment";
                else if (d.value==-1) return "root";
                else return "operation"; 
                //return d.value==1 || d.value==-1? "segment": "operation"
              })
      //nodeEnter.each(create_nodes)
      var root_node = nodeEnter.selectAll(".root")

      root_node.append('circle')
              .attr('r',  2.5)
              .attr('fill', 'black')

      // root_node.append("path")
      //          .each(format_nodes)

      var segment_nodes = nodeEnter.selectAll(".segment")

      segment_nodes.append("path")
              .attr('d', create_rect_path)
              .attr('fill', "lightgray" )
      // segment_nodes.append("path")
      //          .each(format_nodes)

      segment_nodes.append("text")
        .attr("dy", ".15em")
        .attr("y", function(d) { return d.children ? -0 : 0; })
        .style("font-size", "10px")
        .style("text-anchor", "middle")
        .text(function(d) { return d.data.size? d3.format(",")(d.data.size): ''; });
      

      var operation_nodes = nodeEnter.selectAll(".operation")
                                .attr("transform", function(d) { return "translate(" + -oLength/2 + "," + -oWidth/2 + ")"; });


      operation_nodes.append('g')
                .attr("class", function(d) {return d.data.operation.type})

      operation_nodes.append('rect')
          .attr("width", oLength)
          .attr("height", oWidth)
          .attr("fill", 'none')
          .attr("stroke", "gray")

      var range_nodes = operation_nodes.selectAll(".range")

      var range_symbol = range_nodes.append('g')
              .attr("transform", function(d) { return "translate(" + (-oWidth -3) + "," + oWidth/2 + ")"; })

      range_symbol.append('circle')
              .attr('cx', oWidth/2)
              .attr('r', oWidth/2 + 1)
              .attr('fill', function(d){
                var data = d.data.operation;
                if (data.category =='count'){
                  var div = data.div;
                  var action = div.substring(0, div.indexOf('_'))
                  console.log(action)
                  return color(action)
                }else{
                  return 'none'
                }
              })

      range_symbol.append("path")
              //.attr("transform", function(d) { return "translate(" + (-oWidth -1) + "," + oWidth/2 + ")"; })
              .attr('d', function(d){ 

                    var category = d.data.operation.category;
                    if (category == 'time')
                      return clock_symbol(d.data.operation);
                    else if (category == 'count')
                      return hash_symbol(d);

                  })
              .attr('fill', 'white')
              .attr('stroke', '#5c616b')

      var bar =  range_nodes.selectAll("rect")
                .remove()
                .exit()
                .data(d => d.data.node_data)
       
      var bar_enter = bar.enter().append('g')

      

      bar_enter.append("rect")
            .attr("x", function(d){
                return d.x0;
            })
            .attr("width", function(d){
                return d.x1-d.x0;
            })
            .attr("height", oWidth)
            .attr("fill", function(d) {return d.highlighted? "steelblue": "white";})
            .attr("stroke", "#ccc");

      var bar_update = bar_enter.merge(bar);

      var contains_nodes = operation_nodes.selectAll(".contains")


      contains_nodes.append('rect')
          .attr("width", oLength)
          .attr("height", oWidth)
          
          .attr("fill", function(d){return d.data.operation.not? contains_not_color: "white"})

      var circles = contains_nodes.append("g")
                    .attr("transform", function(d) { return "translate(" + oRadius + "," + oWidth/2 + ")"; });

      var circle = circles.selectAll("circle")
                    .remove()
                    .exit()
                    .data(d => d.data.node_data)

      var circle_enter =  circle.enter().append('g')           
      //var radius = (oWidth/2)-1;

      circle_enter.append('circle')
          .attr('r', oRadius)
          //.attr('cx', function(d,i){return i*oRadius*2})
          .attr('cx', function(d){return d.x})
          .attr('fill', function(d){
            return color(d.action);
            //return d.group? color(d.group): "none"
          })
          //.attr('stroke', 'gray')

      circle_enter.append('circle')
          .attr('r', 1)
          .attr('cx', function(d){return d.x})
          .attr('fill', function(d){ return d.many? 'black': 'none'})


      // nodeEnter.append("text")
      //   .attr("dy", ".15em")
      //   .attr("y", function(d) { return d.children ? -0 : 0; })
      //   .style("font-size", "10px")
      //   .style("text-anchor", "middle")
      //   .text(function(d) { 
      //     if (d.data.value == 1)
      //       return d.data.size;
      //     else
      //       return ''; });
      

      // Transition nodes to their new position.
      var nodeUpdate = nodeEnter.merge(node);


      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });


      nodeUpdate.selectAll('path')
            .style("stroke", function(d) { return d.selected ? "black" : 'lightgray';})
      nodeUpdate.selectAll('.segment').selectAll('path')
            .style("fill", function(d){return d.selected_segment? "lightblue": "lightgray"})

      nodeUpdate.selectAll('rect')
            .style("stroke", function(d) { return d.selected ? "black" : 'gray';})
            .style("stroke-width", function(d){return d.selected? "2px": "1px";})




      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
          .remove();


      // Update the links…
      var link = t_svg.selectAll("path.link")
          .data(links, function(d) { return d.id; });

      link.style("opacity", function(d){
                if(!d.data.visible && !d.children)
                    return 0;
                else
                    return 1;
                });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert("path", "g")
          .attr("class", "link")
          .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal(o,o);
          })

      var linkUpdate = linkEnter.merge(link);
      // Transition links to their new position.



      linkUpdate.transition()
          .duration(function(d) {
                          return duration;
                    })
          .attr("d", function(d){return diagonal(d, d.parent)})

      // Transition exiting nodes to the parent's new position.
      var linkExit = link.exit().transition()
          .duration(duration)
          .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
             // if(!d.target.visible && !d.target.children)
             //            return "M0,0";
             //        else
                        return diagonal(o,o);
                    
            
          })
          .remove();

      // Stash the old positions for transition.
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    function hash_symbol(){
      var size = oWidth*0.75;

      //return 'M' + (-size/2) + ',' + (-size/2) +
      return 'M' + oWidth/2 + ',' + (-size/2) +
      'l' + (-size/4) + ',' + size +
      'm0' + size/3 + ',' + 0 +
      'l' + size/4 + ',' + -size +
      'm0' + size/5 + ',' + size/3 +
      'l' + -size + ',0' +
      'm0' + 0 + ',' + size/3 +
      'l' + size + ',0' 
    ;
    }



    // function clock_symbol(o){
      
    //   var size = oWidth*0.75,
    //       r = size/2,
    //       pad = r/4,
    //       len = r - pad,
    //       sym_len = r,
    //       sym_y = (r-sym_len + pad);
    //       //sym_y = -(r + pad);

    //   var clock = 'M' + 0 + ',' + 0 +
    //   ' m' + (-r) + ',0' +
    //   ' a' + r + ',' + r + ' 0 1,0' + (r * 2) + ',0' +
    //   ' a' + r + ',' + r + ' 0 1,0' + (-(r * 2)) + ',0'+
        
    //   'M' + 0 + ',' + (-len) +
    //   'l' + 0 + ',' + len + ' ' + len + ',0';

    //   if (o.div.includes('hour'))
    //     return clock + 
    //     'M' + -(r + pad + sym_len/2) + ',' + sym_y +
    //     'l' + 0 + ',' + sym_len +
    //     'm0' + 0 + ',' + -sym_len/2 +
    //     'l' + sym_len/2 + ',' + 0 +
    //     'm0' + 0 + -sym_len/2 +
    //     'l' + 0 + ',' + sym_len  ;
    //   else if(o.div.includes('date'))
    //     return clock +
    //     'M' + -(r + pad + sym_len/2) + ',' + sym_y +
    //     'l' + 0 + ',' + sym_len +
    //     'q' + (pad*4) + ',' + -(sym_len/4) + ' ' + 0 + ',' + -sym_len;
    //   else if (o.div.includes('duration'))
    //     return clock +
    //     'M' + -(r + pad + sym_len/2) + ',' + sym_y +
    //     'l' + (-sym_len/4) + ',' + sym_len +
    //     'm0' + sym_len/3 + ',' + 0 +
    //     'l' + sym_len/4 + ',' + -sym_len +
    //     'm0' + sym_len/5 + ',' + sym_len/3 +
    //     'l' + -sym_len + ',0' +
    //     'm0' + 0 + ',' + sym_len/3 +
    //     'l' + sym_len + ',0';
    //   else
    //     return clock; 
    // }

    function clock_symbol(o){
      
      var size = oWidth*0.75,
          r = size/2,
          pad = r/4,
          len = r - pad,
          sym_len = r*1.5,
          sym_y = -sym_len/2;
          t = r+pad*2
          //t = -(r + pad + sym_len/2)

      var clock = 'M' + 0 + ',' + 0 +
      ' m' + (-r) + ',0' +
      ' a' + r + ',' + r + ' 0 1,0' + (r * 2) + ',0' +
      ' a' + r + ',' + r + ' 0 1,0' + (-(r * 2)) + ',0'+
        
      'M' + 0 + ',' + (-len) +
      'l' + 0 + ',' + len + ' ' + len + ',0';

      if (o.div.includes('hour'))
        return clock + 
        'M' + t + ',' + sym_y +
        'l' + 0 + ',' + sym_len +
        'm0' + 0 + ',' + -sym_len/2 +
        'l' + sym_len/2 + ',' + 0 +
        'm0' + 0 + -sym_len/2 +
        'l' + 0 + ',' + sym_len  ;
      else if(o.div.includes('date'))
        return clock +
        'M' + t + ',' + sym_y +
        'l' + 0 + ',' + sym_len +
        'q' + (pad*6.5) + ',' + -(sym_len/4) + ' ' + 0 + ',' + -sym_len;
      else if (o.div.includes('duration'))
        return clock +
        'M' + t + ',' + sym_y +
        'l' + 0 + ',' + sym_len +
        'l' + sym_len/2 + ',' + 0;
      else
        return clock; 
    }


    function diagonal(s, d) {

      var t = s.data? (s.data.translate_x | 0): 0;

      return "M" + s.x + "," + s.y
           + "C" + s.x + "," + (s.y + d.y) / 2
           + " " + (d.x + t) + "," +  (s.y + d.y) / 2
           + " " + (d.x + t) + "," + d.y;
    }



    // Toggle children on click.
    function hide_children(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update(d);
    }

    function format_nodes(d, i) {

        d = d.data
        n = node_types[d.value];

        if (d.visible) 
          size = n.size;
        else
          size = 0;

        shape = n.shape;

        d3.select(this)
            .attr("d", function(d) { return d.value==1? create_rect_path(d):
                         d3.symbol().size(size).type(d3.symbolCircle)

                        ();
                      })
            //.style("stroke", function(d) { return d.selected ? "black" : n.stroke;})
            .style("fill", n.fill)
            //.style("stroke-width", n.stroke_width);


    }

    function reset_filters(exception) {

      // l.filterAll();
      // h.filterAll();
      // hour.filterAll();
      // len.filterAll();

      //action_strings.filterAll();

      //max_id = 3
      console.log('MAX RESET ID', max_id)
      if (!arguments.length)
        exception = -1;

      for(var i=0; i<= max_id; i++){
        if (i != exception){
          reset(i);
          //charts[i].dimension().filterAll();
          //charts[i].filter_dimension().filterAll();


        }   


      }


    }
    var dim;
    function apply_filters(selected){

      var selected_filters = selected.data.filters;
          if (dim) {
              dim.filterAll();
              reset_filters();

            }
          if(selected_filters) {

            console.log('SELECTED FILTERS', selected_filters);

            selected_filters.forEach(function(f){
              type = f.type;

              if (type == 'range') {
              
                var div = f.div;
                var extents = f.extents;

                // current_chart = chart_data[div];
                // dim = current_chart.dim;
                // reset(current_chart.id);

                current_chart = f.chart.data()[0];
                dim = current_chart.filter_dimension();
                reset(current_chart.id);

                if (extents){
                  console.log('extents to filter', extents)

                  dim.filterFunction(function(d){
                    var inRange = true;
                    if (extents.pos)
                      inRange= inRange && (d >= extents.pos[0]) && (d < extents.pos[1]);

                    extents.neg.forEach(function(ext){
                      inRange = inRange && !((d>=ext[0]) && (d< ext[1]));

                    })

                    return inRange;
                  })
                }
                else
                  dim.filterExact(null);

              } else if (type == 'contains'){

                dim = action_strings;

                char_regex = f.regex;
                console.log('CHAR REGEX', char_regex);
                dim.filterFunction(function(d){


                    return d.match(char_regex);

                });
                
              }
              console.log('filtered-size', all.reduceCount().value());
              renderAll();

            })
            
          }


    }
    
    function select_node(d){

       if(!selected){
           selected = d;
           d.selected = true;
        } 
        else {
           selected.selected = false;
           update(selected);
           selected = d;
           d.selected = true;
           
        }


        console.log("Selected node: ", selected);

        show_node_view(selected);
      
        //find_all_patterns();

        if (selected.data.value == 1) {
          if (!selected_segment){
            selected_segment = selected;
            selected.selected_segment = true;
          }else{
            selected_segment.selected_segment = false;
            update(selected_segment);
            selected_segment = d;
            d.selected_segment = true;
          }

          update_info_view("info_view");
          new_selection = true;
        
          apply_filters(selected)

          new_selection = false;
          console.log('The current selection has ' + selected.data.size + ' sequences!' );
          update_horizontal_chart_data();
          update_action_transition_graph();

          print_sequences();

        } else {
          update_builder_view(selected.data.operation);
        }


        update(selected);
        resize_windows()
        //showDiv();


    }





    function showDiv() {
      d3.select("#attributes").style("display", "block");
    }

    function add_child_node(d, node_obj, display) {

      var display = !display;
      if (d.children == null) {
          d.children = [];
        }

      node_obj.visible = 1;

      id = ++i;
      new_node = d3.hierarchy(node_obj);
      new_node.depth = d.depth + 1;
      new_node.height = d.height;
      new_node.parent = d;
      new_node.id = id;

      if (display)
        d.children.push(new_node);
      else{
        d.not_children = [];
        d.not_children.push(new_node);
      }


      return new_node;
      

    }


    //******** horizontal chart ***********
    var char,
        axis_translate = node_radius*2;
    var margin_hc = {top: 20, right: 20, bottom: 30, left: 100},
      width_hc = 300 - margin_hc.left - margin_hc.right,
      height_hc = 175 - margin_hc.top - margin_hc.bottom,
      horizontal_chart = d3.select("#contains_action_chart").append('svg').append("g").attr("transform", "translate(" + (margin_hc.left-axis_translate) + "," + margin_hc.top + ")");

      
      console.log('svg width', width_hc);
      console.log('svg height', height_hc);

      var x_hc = d3.scaleLinear()
              .rangeRound([0, width_hc]);

      var y_hc = d3.scaleBand()
              .rangeRound([0, height_hc])
              .paddingInner(0.1);

      var z_hc = d3.scaleOrdinal()
          .range(['steelblue', '#dee2e8'])

      var yAxis_hc = d3.axisLeft(y_hc);


    function update_horizontal_chart_data() {
      total_size = all.reduceCount().value();  
      all_matches = [];
      for(var char_key in alphabet_rev){
        char = char_key;
        matches = all.reduce(reduceAdd, reduceRemove, reduceInitial).value(); 
        
        if (matches){
          action = alphabet_rev[char_key];
          
          abs_matches = matches.count;
          //if char_key in current level of hierarchy!
          
          if (current_level.includes(action)) {
            percent_matches = abs_matches*100/total_size;
            
            m = { 'action': action, 'id':action, 'char': char_key, 'abs': abs_matches, 'percent': percent_matches, 'not_percent': 100-percent_matches}
            all_matches.push(m);
           }

        }
        
      }

      
      all_matches.sort(function(a,b) {return b.abs - a.abs;});

      var data = all_matches,
          keys = ["percent", "not_percent"];

      z_hc.domain(keys);

      data.forEach(function (d) {
          var x0 = 0;
          d.percents = z_hc.domain().map(function (name) { return { name: name, value: d.abs, x0: x0, x1: x0 += +d[name] }; });
          d.total = d.percents[d.percents.length - 1].x1;

      });


      data.sort(function (a, b) { return b.total - a.total; });

      x_hc.domain([0,100]);
      y_hc.domain(data.map(function(d){return d.action;
          })
      );
      
      //update_horizontal_chart(all_matches);
      update_horizontal_chart(data)


      function reduceInitial() {
        return {
            count: 0
        };
      }

      function reduceAdd(p, v) {
        if (v.general_actions.includes(char))
          p.count = p.count + 1;
        
        return p;

      }

      function reduceRemove(p, v) {
        if (v.general_actions.includes(char))
          p.count = p.count - 1;
        
        return p;

      }
    }

    function select_horizontal_action(d){
      select_action_node(d);
      clear_contains_builder();
      add_action_node()


    }

    function update_horizontal_chart(data){
           
               //drawing chart
      var row = horizontal_chart
          .selectAll("g")
              .remove()
              .exit()
              .data(data)
              

      var row_enter = row.enter().append("g")
              .attr("transform", function (d) { return "translate(" + axis_translate + "," + y_hc(d.action) + ")"; })


      var node = row_enter.append('circle')
              .attr("transform", function (d) { return "translate("+ -((axis_translate + 8)/2) +"," + y_hc.bandwidth()/2 + ")"; })
              .attr("r", node_radius)
              .attr("fill", function(d){ return color(d.action)})
              .on('click', select_horizontal_action)


              
      var bar_enter = row_enter.selectAll("rect")
            .remove()
            .exit()
            .data(d => d.percents)
            .enter();


      bar_enter.append("rect")
            .attr("x", function(d){
                return x_hc(d.x0);
            })
            .attr("height", function(d){
                return y_hc.bandwidth();
            })
            .attr("width", function(d){
                return x_hc(d.x1) - x_hc(d.x0);
            })
            .attr("fill", function(d) {return z_hc(d.name);});

      bar_enter.append("text")
          .text(function(d) {
                abs = d.value;
               value = d.x1 - d.x0;
               eligible = (d.name == "percent") && (value >= 0);
               return  eligible ? d3.format(".1s")(abs) + ', ' + d3.format(",.0%")(value/100) : ""; 
             })
          .attr("x", function(d) {
            if ((d.x1-d.x0) > 20)
              return x_hc(d.x0)+(x_hc(d.x1) - x_hc(d.x0))/2 - 10;
            else
              return x_hc(d.x1 + 1);
          })
          .attr("y", y_hc.bandwidth()*3/4)
          .style("fill", 'black');

      row_enter
        .on("click", function(d) {
          //update_selected_bar(d3.select(this).select('.outer_box'));
          //update_selected_bar(d)
          
          //select_action_node(d)
          select_horizontal_action(d)
          selectedFilter.div = 'action_strings';
          selectedFilter.chart = d3.select("#contains_action_chart");
          selectedFilter.char = d.char;
          selectedFilter.regex = '.*' + d.char + '.*';
          selectedFilter.size = d.abs;
          selectedFilter.type = 'contains'; 
          selectedFilter.pattern = [any_node, {action:alphabet_rev[d.char], char:d.char, many:false}, any_node]


        })

      row_enter.append("rect")
          .attr("class", "outer_box")
          .attr("x", x_hc(0))
          .attr("height", function(d){
                  return y_hc.bandwidth()
              })
          .attr("width", x_hc(100))
          .attr("fill", "none");

      var row_update = row_enter.merge(row)

      row_update.selectAll('circle')
          .style('stroke', function(d){return d.selected? 'black': 'none'})
      row_update.select('.outer_box')
          .style('stroke', function(d){return d.selected? 'black': 'none'})


      horizontal_chart.append('g').attr("class", "noAxis")
                  .call(yAxis_hc)


      


    }

    function update_thresholds(){

      console.log('current partitions', partitions);
      console.log('current x-range domain', builder_range.domain());
      var x_min = builder_range.domain()[0]
      var isNumber = false;
      if (typeof x_min == 'number')
        isNumber = true;
      new_thresholds = [builder_range.domain()[0]]
      partitions.forEach(function(p) {
        var value = isNumber? parseFloat(p.value) : p.value;

        new_thresholds.push(value);
      })
      thresholds = new_thresholds.sort(function(a, b){return b-a});
      console.log('updated thresholds', thresholds);
    }


    function create_partition() {
      if (selected && selected_chart) {

        update_thresholds();
        

        var d = selected_segment,
            dim,
            dims;

        chart_id = selected_chart.attr('id');
        var selected_chart_data = selected_chart.data()[0],
            range = selected_chart_data.range(),
            current_range =selected_chart_data.current_range(),
            dim = selected_chart_data.dimension()
            //dims = selected_chart_data.group()

        update_oScale(range);

        var info_range = range, //range used for info view
            node_range = current_range //range used for workflow view

        var node_data,
            threshold_ranges =[],
            results = [],
            operation = {
              'type': 'range',
              'action': 'partition',
              'value': 2,
              'category': selected_chart.data()[0].category(),
              'thresholds': thresholds.slice(),
              'div': chart_id,
              'chart': selected_chart,
              'results': results,
              'range': range,
              'current_range': current_range
            };

        name = 'NEW Partition!';
        partition_data = { 'name': name,
                     'value': 2,
                     'operation': operation
                   };


        partition_node = add_child_node(d, partition_data);

        

        // chart_div = chart_data[chart_id];
        // dim = chart_div.dim1;
        // dims = chart_div.dims;



        console.log('thresholds for grouping', thresholds)
        console.log('Number of seqs: ', all.reduceCount().value())
        groups = dim.group(function(d) {
            return group_count(d, thresholds);
          }).all()

        partition = {};
        partition.div = chart_id;
        //partition.groups = groups;

        //max_key = dims[dims.length-1].key;
        max_key = current_range[1]

        d_filters = d.data.filters;
        d_size = d.data.size;

        low_bound = 0;

        // partition_data.partitions = [];
        
        partition_data.fullSize = d_size;

        var filter = { 
              chart: selected_chart,
              div: chart_id,
              type: 'range',
              range: info_range


          }
        
        for (var i = 0; i < groups.length; i++) {
          g = groups[i];
          low_bound = g.key;
          next = groups[i+1];
          if (next)
            high_bound = next.key;
          else
            high_bound = max_key;
          extents = [low_bound, high_bound];
          size = g.value;
          
          oScale = update_scale(node_range, oRange)

          var translate_x = oScale(low_bound) + ((oScale(high_bound)-oScale(low_bound))/2) - (oLength)/2;

          threshold_ranges.push(extents);
          // var partition = {};
          // partition.range = extents;
          // partition.size = size;
          // partition.percent = size/d_size;
          // partition_data.partitions.push(partition);


          filter.extents = extents;
          filter.size = size;

          var filter_data = get_filter_data_for_segment(d, filter),
              filter_copy = filter_data.filter,
              filters = filter_data.agg_filters,
              operations = filter_data.operations;
          

          results.push(filter_copy);

          name = 'NEW SEGMENT!'
          segment_data = { 'name': name,
                     'value': 1,
                     'filters': filters,
                     'operations': operations,
                     'size': size,
                     'translate_x': translate_x
                   };

          segment_node = add_child_node(partition_node, segment_data);

        }
        
        partition_data.operation.threshold_ranges = threshold_ranges
        oScale = update_scale(node_range, oRange)
        partition_data.node_data = create_range_partition_data(threshold_ranges, oScale);

        update(d);
        
      } else {
        if (!selected)
          alert('Segment was not selected!');
        else
          alert('Please choose range to filter!');
      } 



    }



    function update_extents(old_extents, new_extents, not){

      var not = not? true: false,
          updated_extents ={'pos':[], 'neg':[]};

      updated_extents.pos = old_extents.pos;
      updated_extents.neg = old_extents.neg.slice();

      if(not){
        updated_extents.neg.push(new_extents);
      }else{

        var old = old_extents.pos;
        if (old){ 
          min = old[0] < new_extents[0] ? old : new_extents;
          max = min == old ? new_extents : old;

          if (min[1] < max[0])
            updated_extents.pos = null;
          else
            updated_extents.pos = [max[0], (min[1]< max[1]? min[1]: max[1])];
        }else{
          updated_extents.pos = new_extents;
        }
      }
      console.log('UPDATED EXTENTS', updated_extents);
      return updated_extents

    }

   
    function create_action_regex(regexes){
      s = '^'

      regexes.pos.forEach( function(r){
        s = s + '(?=' + r + ')';
      })

      if (regexes.neg.length>0){
        s = s + '(?!(';
        
        regexes.neg.forEach( function(c){

            s = s + c + '|';
        })
        s = s.slice(0,-1);
        s = s + '))';
      }

      s = s + '.*$';

      console.log('action regex created: ', s);

      return s;

    }





    var oLength = 50,
        oWidth = 10,
        oRange = [0,oLength],
        oScale,
        oRadius = 3.5;

    function update_oScale(range){

      if(typeof range[0] == "number")
        oScale = d3.scaleLinear().range(oRange)
      else
        oScale = d3.scaleTime().range(oRange)

      oScale.domain(range);

    }

    function update_scale(domain_range, range){

      if(typeof domain_range[0] == "number")
        scale = d3.scaleLinear()
      else
        scale = d3.scaleTime()

      scale.clamp(true)
      scale.range(range)
      scale.domain(domain_range);

      return scale

    }

    function convert_neg_to_pos_ranges(full_range, filtered_range){

      var ranges = []

      if (full_range[0] != filtered_range[0])
        ranges.push([full_range[0], filtered_range[0]])

      if (full_range[1] != filtered_range[1])
        ranges.push([filtered_range[1], full_range[1]])

      if (ranges.length == 0)
        ranges.push(full_range)

      return ranges
    }



    function create_contains_filter_data(filter, max_length){
      var node_data = [],
          pattern = filter.pattern,
          n = pattern.length,
          count = 0;


      pattern.forEach(function(p){
        count += p.action? 0: 1;
      })

      var n_nodes = n-count,
          total_whitespace = max_length -(oRadius*2*n_nodes);
          space = count? total_whitespace/count: total_whitespace,
          adjust =0,
          x=0;

      if (space<0){
        adjust= total_whitespace/(n_nodes-1),
        space= 0;

      }


      pattern.forEach(function(p){

        if(p.action){
          p.x = x;
          node_data.push(p);
          x +=  (oRadius*2)+ adjust;
        }else{
          x +=space;
        }
        
        
      })


      return node_data
    }


    function create_range_filter_data(filter, scale){
      
      if (filter.not)
        $('#range_not_button').prop('checked', true);
      else
        $('#range_not_button').prop('checked', false);

      var value = filter.not? true: false,
          range = filter.range,
          extents = filter.extents,
          node_data = [];

      scale.clamp(true);

      if (range[0] != extents[0])
        node_data.push({
          x0: scale(range[0]),
          x1: scale(extents[0]),
          highlighted: value

        });

      node_data.push({
        x0: scale(extents[0]),
        x1: scale(extents[1]),
        highlighted: !value

      })

      if (range[1] != extents[1])
        node_data.push({
          x0: scale(extents[1]),
          x1: scale(range[1]),
          highlighted: value

        });

      console.log('node_data for range filter', node_data)

      return node_data
    }

    function create_range_partition_data(thresholds, scale){
      var node_data = [];

      //update_oScale(range);
      scale.clamp(true);

      thresholds.forEach(function(t){
        node_data.push({
          x0: scale(t[0]),
          x1: scale(t[1]),
          highlighted: false
        })

      })

      return node_data


    }


    function show_not_filter(){

      if(selected && selected.data.value==0){
        var d= selected;

        d.children.push(d.not_children[0]);

        update(selected);

      }else{
        alert('Please select filter')
      }
    }


    function create_agg_filter_set(old_set, new_filter) {
    
      var old_filter,
          foundFilter=false,
          chart_div = new_filter.div,
          filters = old_set? old_set.slice(): [];


        for( var i = 0; i < filters.length; i++){
          var f = filters[i];
          if (f.div == chart_div){
            old_filter = f;
            foundFilter = true;
            break;
          }
        }

        if (foundFilter){
          filters.splice(f, 1);
        }

        var filter = {};
        
        filter.div = chart_div;
        filter.not = new_filter.not? true: false;
        filter.chart = new_filter.chart;
        filters.push(filter);
        

        if (new_filter.type == 'range') {

          
          filter.type = 'range';

          if (foundFilter){

            filter.extents = update_extents(old_filter.extents, new_filter.extents, new_filter.not);
          }
          else {
            filter.extents ={},
            filter.extents.neg =[],
            filter.extents.pos = null;

            if(new_filter.not){
              filter.extents.neg.push(new_filter.extents);
            } else{
              filter.extents.pos = new_filter.extents;
            }
            
          }

          
          
        } else if(new_filter.type == 'contains') {
          filter.regexes ={};
          filter.regexes.pos =[],
          filter.regexes.neg =[],
          filter.chars ={
            pos: [],
            neg: []
          };

          if (foundFilter){
              filter.regexes.pos = old_filter.regexes.pos.slice();
              filter.regexes.neg = old_filter.regexes.neg.slice();
              filter.chars.pos = old_filter.chars.pos.slice();
              filter.chars.neg = old_filter.chars.neg.slice();
              
          }
          if (new_filter.not){
            filter.chars.neg.push(new_filter.char);
            filter.regexes.neg.push(new_filter.regex);
          }else{
            filter.chars.pos.push(new_filter.char);
            filter.regexes.pos.push(new_filter.regex);
          }
          filter.regex = create_action_regex(filter.regexes);
          filter.char = new_filter.char;
          filter.type = 'contains';
          console.log('REGEXES', filter.regexes);
        }


        return filters
    }


    function add_filter_to_set(old_set, new_filter_copy){
      var filters = old_set? old_set.slice(): []
          //filter_copy = copy_filter(new_filter)

      filters.push(new_filter_copy)

      return filters
    }


    function copy_filter(filter){
      var filter_copy = JSON.parse(JSON.stringify(filter))

      filter_copy.not = filter.not | false;
      filter_copy.chart = filter.chart;

      if (filter.extents)
        filter_copy.extents = filter.extents.slice()

      if(filter.range)
        filter_copy.range = filter.range.slice()

      if(filter.current_range)
        filter_copy.current_range = filter.current_range.slice()

      return filter_copy
    }

    function get_filter_data_for_segment(selected_segment, new_filter){
      var d = selected_segment.data,
          filter_copy = copy_filter(new_filter);

      filter_copy.results = { in_size: d.size, out_size: filter_copy.size}

      var operations = add_filter_to_set(d.operations, filter_copy)
          agg_filters = create_agg_filter_set(d.filters, filter_copy)



      return { filter: filter_copy,
              agg_filters: agg_filters,
              operations: operations}
    }

    function create_filter(parent_segment) {

      var d = parent_segment || selected_segment;

      if (d && selectedFilter.type && d.data.value==1) {
        // var d_filters = d.data.filters,
        //     d_operations = d.data.operations,
        var node_data=[],
            translate_x = 0;
            

        

        if(selectedFilter.type =='range'){
          oScale = update_scale(selectedFilter.range, oRange)
          node_data = create_range_filter_data(selectedFilter, oScale)
          for(var i=0; i <node_data.length;i++){
            var nd = node_data[i];
            if (nd.highlighted){
              translate_x = nd.x0 + (nd.x1-nd.x0)/2 - oLength/2
            }
          }
        }
        else if(selectedFilter.type == 'contains'){
          node_data = create_contains_filter_data(selectedFilter, oLength)
          node_data = selectedFilter.pattern
        }


        // var filter_copy = copy_filter(selectedFilter), 
        //     operations = add_filter_to_set(d_operations, filter_copy),
        //     filters = create_agg_filter_set(d_filters, selectedFilter);

        var filter_data = get_filter_data_for_segment(d, selectedFilter),
            filter_copy = filter_data.filter, 
            operations = filter_data.operations,
            filters = filter_data.agg_filters;

        console.log('selected filter div', selectedFilter.div)
        
        console.log('Filter Data', filter_data)

        prev_size = d.data.size;
        size = selectedFilter.size;


       
        filter_copy.action = 'filter';
        filter_copy.value = 0;

        name = 'NEW Filter!';
        filter_data = { 'name': name,
                     'value': 0,
                     'operation': filter_copy,
                     'node_data': node_data

                   };

        filter_node = add_child_node(d, filter_data);
        

        var segment_data = { 'name': name,
                     'value': 1,
                     'operations': operations,
                     'filters': filters,
                     'size': size,
                     'prev_size': d.data.size,
                     'translate_x': translate_x
                   };

        var segment_node = add_child_node(filter_node, segment_data);


        selectedExtents = null;
        selectedChar = null;

        
        update(d);

        selectedFilter = {};

        return filter_node;
        
      } else {
        if (!selected_segment)
          alert('Segment was not selected!');
        else if (d.value != 1)
          alert('Can only filter segments!')
        else
          alert('Please choose range to filter!');

      }  



    }


    function toggle_segments(d){
      var treeData = tree(root);
      var nodes = treeData.descendants();

      nodes.forEach(function(d) {
            if (d.value == 1)
                 d.data.visible = 1 - d.data.visible;
        });

      update(root);
    }



    function remove_filter(){


      d = selected

      if (d.parent && d.parent.children && d.data.value !=1){
            console.log('removing ' + d.data.name);
            d.parent.children.forEach( function(n){
              if (n.id == d.id){
                nodeToDelete = n;

              }

            });
            console.log('node :', nodeToDelete);
            if (nodeToDelete){
                d.parent.children = _.without(d.parent.children, nodeToDelete);
                if(d.parent.children.length==0){
                  d.parent.children = null;
                };
            }
      } else {
        alert('Please select a filter to be removed!');
      } 


      update(d.parent)

    }

    // function filter_partition(d){
    //   parent = d.parent;

    //   if (parent.data.value == 2) {
    //     parent.data.value = 3;
    //     parent._children = parent.children;
    //     parent.children = [];
    //     parent.children.push(d);
    //   } else if (parent.data.value == 3) {
    //     parent.data.value = 2;
    //     parent.children = parent._children;
    //   }
    //   update(parent);
    // }


    function create_rect_path(d) {
        d = d.data;


        height = RECT_H; //fixed height
        //width = RECT_W;
        width = wScale(d.size)

        //parent_size = d.parent.size

        if (!d.visible) {
          height = 0;
          width = 0;
        }

        return 'M' + (-width/2) + ',' + (-height/2) +
          'l' + '0,' + height +
          'l' + width+ ',' + 0 +
          'l' + '0,' + -height +
          'l' + -width + ',0';


    }
    var only_path = 0

    var toggleColor = (function(){
       var currentColor = "white";

        return function(){
            currentColor = currentColor == "white" ? "magenta" : "white";
            d3.select(this).style("fill", currentColor);
        }
    })();

    function show_path_only() {

      only_path = !only_path;

      //toggle_button_color("#path_button")
      // current_color = current_color == original_color? pressed_color : original_color;
      // d3.select("#path_button").style("background-color", current_color);

      n = selected;

      while(n.value !=-1) {
          p = n.parent;
          if (only_path) {
            p._children = p.children;
            p.children = [];
            p.children.push(n);
          } else {
            p.children = p._children;
          }

          n = p;


      }

      update(root);

    }


    //make sure first node is selected
    select_node(root.children[0])
    window.addEventListener('resize', resize_windows)
    resize_windows()



  });
});

});

</script>
    
  </body>
</html>