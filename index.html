<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Tree Example</title>
    <link rel="stylesheet" href="style1.css" />
    <meta http-equiv="content-type" content="text/html; charset=UTF8"> 

    <style>

    
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700);

      body {
        font-family: "Helvetica Neue";
        /*margin: 40px auto;*/
        /*        width: 960px;
                min-height: 2000px;*/
      }

      #body {
        position: relative;
      }

      text {

        font: 10px sans-serif;
      }

      h1 {
        font-size: 96px;
        margin-top: .3em;
        margin-bottom: 0;
      }

      h1 + h2 {
        margin-top: 0;
      }

      h2 {
        font-weight: 400;
        font-size: 28px;
      }

      h1, h2 {
        font-family: "Yanone Kaffeesatz";
        text-rendering: optimizeLegibility;
      }

      #body > p {
        line-height: 1.5em;
        width: 640px;
        text-rendering: optimizeLegibility;
      }

      /*      #charts {
              padding: 2px 0;
            }*/

      .leftovers {
        fill: gray;
      }

      /*      .chart {
              display: inline-block;
              height: 151px;
              margin-bottom: 10px;
            }*/

      .reset {
        padding-left: 1em;
        font-size: smaller;
        color: #ccc;
      }

      .background.bar {
        fill: #ccc;
      }

      .foreground.bar {
        fill: steelblue;
      }

      .partition rect{
        fill: steelblue;
      }

      .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }

        /*    .axis text {
              font: 10px sans-serif;
            }
        */
      .axisY path, .axisY line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }

        /*    .axisY text {
              font: 10px sans-serif;
            }
        */

      .noAxis path, .noAxis line {
        fill: none;
        stroke:none;
        shape-rendering: crispEdges;
      }

      .brush rect.extent {
        fill: steelblue;
        fill-opacity: .125;
      }

      .brush .resize path {
        fill: #eee;
        stroke: #666;
      }

      .links line {
        stroke: #999;
        stroke-opacity: 0.6;
      }

      .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
      }

    </style>

  </head>

  <body>


<div class= "wrapper" id="wrapper">
  <div class= "graph" id= "tree"></div>
  <div class= "button_box" id="buttons">
      <div class= "button" id="filter_button">
        <input name="filterButton" 
                     type="button" 
                    value="Add Filter" 
                     />
      </div>
      <div class= "button" id="remove_button">
        <input name="removeButton" 
                     type="button" 
                    value="Remove Filter!" />
      </div>
      <div class= "button" id="segment_button">
        <input name="segmentButton" 
                     type="button" 
                    value="Toggle segments!" />
      </div>
      <div class= "button" id="path_button">
        <input name="pathButton" 
                     type="button" 
                    value="Show only path" />
      </div>
      <div class= "button" id="partition_button">
        <input name="groupButton" 
                     type="button" 
                    value="Add Partition" />
      </div>
      <div class= "button" id="apply_funnel_button">
        <input name="funnelButton" 
                     type="button" 
                    value="Apply Funnel" />
      </div>
      <div class= "button" id="action_button">
        <input name="actionButton" 
                     type="button" 
                    value="Contains actions" />
      </div>
      <div class= "button" id="demo_button">
        <input name="demoButton" 
                     type="button" 
                    value="DEMO" />
      </div>
  </div>

  <div class="charts" id="right_panel">
    
    <div class="charts" id="info_box">
      <div class="info" style="display:none;" id="create_partition_view">
        <div class="title"> Create Partition View </div> 
          <div class= "button" id="addPartition_button">
              <input name="addPartitionButton" 
                           type="button" 
                          value="Add Partition" />
          </div>
        <div class= "button"  id="removePartition_button">
          <input name="removePartitionButton" 
                       type="button" 
                      value="Remove Partition" />
        </div>
        <div class= "button" id="applyPartition_button">
          <input name="applyPartitionButton" 
                       type="button" 
                      value="Apply Partition" />
        </div>
        
        <div class= "button" id="input_partition_value">
            <input type="text" id="partition_value">
        </div>
      </div>  

      <div class="info" style="display:none;" id="segment_view">
        <div class="title"> Segment View </div>
      </div>

      <div class="info" style="display:none;" id="filter_view">
        <div class="title"> Filter View </div>
      </div>

      <div class="info" style="display:none;" id="partition_view">
        <div class="title"> Partition View </div>

      </div>

    </div>

    <div class="charts" style="display:none;" id="attributes">

      <div class="charts" id="chart_box">
        <div class="chart" id="len_chart"> 
          <div class="title"> Number of Actions </div>
        </div>
        <div class="chart" id="duration_chart"> 
          <div class="title"> Duration chart </div>
        </div>
        <div class="chart" id="hour_chart"> 
            <div class="title"> Start hour chart </div>
        </div>
        <div class="chart" id="date_chart"> 
            <div class="title"> Start Date </div>
        </div>
      </div>

      <div class= "charts" id= "list_box">
        <div class= "chart" id="contains_action_chart">
            <div class="title"> Number of Sequences that Contains Action </div>
          </div>
        </div>

        <div class ="charts" id="action_transition">
          <div class ="chart" id="node_link">
          </div>
          <div  class="chart" id="pattern_builder">
            <div  class="chart" id="pb_graph">
            </div>
            <div class="button_box" id="pb_buttons">
              <div class= "button" id="add_node_button">
                <input name="addNodeButton" 
                             type="button" 
                            value="Add Action Node" 
                             />
              </div>
              <div class= "button" id="remove_node_button">
                <input name="removeNodeButton" 
                             type="button" 
                            value="Remove Node" />
              </div>
              <div class= "button" id="create_funnel_button">
                <input name="addLinkButton" 
                             type="button" 
                            value="Create Funnel" />
              </div>
            </div>

          </div>
          <div class="chart" id="adjacency_chart"></div>
        </div>

        



    </div>

    
</div>



<!-- load the d3.js library --> 
<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

<script src="js/crossfilter.js"></script>
<!-- <script src="dist/rangebar.js"></script> -->

    
<script>

$(document).ready(function(){

  var node_types = {},
      filter = {},
      filter_p = {},
      segment = {},
      partition = {},
      top_level = {};

  partition.value = 2;
  partition.shape = "diamond";
  partition.fill = "lightgreen";
  partition.stroke = "lightgreen";
  partition.stroke_width = "1px";
  partition.size = 300;

  node_types[partition.value] = partition;

  filter.value = 0;
  filter.shape = "triangle-down";
  filter.fill = "lightblue";
  filter.stroke = "lightblue";
  filter.stroke_width = "1px";
  filter.size = 300;

  node_types[filter.value] = filter;

  filter_p.value = 3;
  filter_p.shape = "triangle-down";
  filter_p.fill = "lightgreen";
  filter_p.stroke = "lightgreen";
  filter_p.stroke_width = "1px";
  filter_p.size = 300;

  node_types[filter_p.value] = filter_p;

  segment.value = 1;
  segment.shape = "square";
  segment.fill = "lightgray",
  segment.stroke = "lightgray",
  segment.stroke_width = "3px";
  segment.size = 1000;

  node_types[segment.value] = segment;

  top_level.value = -1;
  top_level.shape = "circle",
  top_level.fill = "black",
  top_level.stroke = "black",
  top_level.stroke_width = "1px";
  top_level.size = 20;

  node_types[top_level.value] = top_level;

  chart_data = {},
  hour_chart ={},
  start_chart = {},
  duration_chart = {},
  len_chart = {};

  chart_data['hour_chart'] = hour_chart;
  chart_data['date_chart'] = start_chart;
  chart_data['duration_chart'] = duration_chart;
  chart_data['len_chart'] = len_chart;


  var selectedFilter ={},
      selectedDiv,
      selectedChar,
      selectedExtents,
      new_selection = false.
      thresholds = [20, 10, 5, 2, 1, 0];

  var dataset = []
  var parseDate = d3.timeParse("%Y-%m-%d %H:%M:%S.%L")
  //var parseTimeDelta = d3.timeParse("%d %H:%M:%S.%L")

  var csv_file = "sample_table.csv"; //100K
  //var csv_file = "sample_table1.6M.csv";
  var seq_data;



d3.csv(csv_file, function(error, data) {
  if (error) throw error;
  seq_data = data;

  d3.csv('alphabet1.csv', function(error1, alpha_data) {
      if (error1) throw error1;
      data= seq_data;

      data.forEach(function(d){

        d.len = +d.len;
        d.index = +d.index;
        d.start_index = +d.start_index;
        d.end_index = +d.end_index;
        d.start = parseDate(d.start);
        d.end = parseDate(d.end);
        d.dur = d.end -d.start;
      });


      alphabet = {},
      alphabet_rev = {};
      alpha_data.forEach(function(d){

        alphabet[d.Action] = d.Character;
        alphabet_rev[d.Character] = d.Action
      })

      alphabet['start'] = '0';
      alphabet['exit'] = '1';
      alphabet_rev['0'] = 'start';
      alphabet_rev['1'] = 'exit';

      console.log('Alphabet: ', alphabet);
      console.log('data', data[2])


      var seqs = crossfilter(data),
          all = seqs.groupAll(),
          len = seqs.dimension(function(d) {return d.len;}),
          l = seqs.dimension(function(d) {return d.len;}),
          //lens = len.group(Math.floor),
          lens = len.group(function(d) {
            //return group_count(d);
            return d;
          }),

          
          hour = seqs.dimension(function(d) {return d.start.getHours() + d.start.getMinutes()/60;}),
          h = seqs.dimension(function(d) {return d.start.getHours() + d.start.getMinutes()/60;}),
          hours = hour.group(Math.floor),
          

          start = seqs.dimension(function(d) {return d.start}),
          start_filter = seqs.dimension(function(d) {return d.start}),
          starts = start.group(d3.timeDay);
          
          interval = 1000*60*60
          duration = seqs.dimension(function(d) {return (d.end - d.start)/(interval)});
          dur_filter = seqs.dimension(function(d) {return (d.end - d.start)/(interval)});
          durations = duration.group(Math.floor);

          action_strings = seqs.dimension(function(d) {return d.general_actions});


    //console.log(lens.top(Number.POSITIVE_INFINITY).length);



    len_chart.dim = l;
    len_chart.dim1 = len;

    hour_chart.dim = h;
    hour_chart.dim1 = hour;

    start_chart.dim = start_filter;
    start_chart.dim1 = start;

    duration_chart.dim = dur_filter;
    duration_chart.dim1= duration;

    len_chart.dims = lens.all();
    
    hour_chart.dims = hours.all();
    start_chart.dims = starts.all();
    duration_chart.dims = durations.all();
    
    d3.select("#filter_button")
      .on("click", create_filter);
    d3.select("#partition_button")
      .on("click", show_partition_view);
    d3.select("#remove_button")
      .on("click", remove_filter);
    d3.select("#segment_button")
      .on("click", toggle_segments);
    d3.select("#path_button")
      .on("click", show_path_only);
    d3.select("#action_button")
      .on("click", contains_action);
    d3.select("#addPartition_button")
      .on("click", add_partition_bar);
    d3.select("#removePartition_button")
      .on("click", remove_partition_bar);
    d3.select("#applyPartition_button")
      .on("click", create_partition);
    d3.select("#demo_button")
      .on("click", show_not_filter);
    d3.select("#add_node_button")
      .on("click", add_action_node);
    d3.select("#create_funnel_button")
      .on("click", create_funnel)
    d3.select("#apply_funnel_button")
      .on("click", apply_funnel)
    d3.select("#remove_node_button")
      .on("click", remove_action_node)


    var charts = [

          barChart()
          .dimension(len)
          .dim_name('# of actions')
          .group(lens)
          .x(d3.scaleLinear()
          .domain([0, 30])
          .rangeRound([0, 140])),

          barChart()
          .dimension(duration)
          .dim_name('Duration (hours)')
          .group(durations)
          .x(d3.scaleLinear()
          .domain([0, 30 ])
          .rangeRound([0, 10])),

          barChart()
          .dimension(hour)
          .dim_name('Hour of the day')
          .group(hours)
        .x(d3.scaleLinear()
          .domain([0, 24])
          .rangeRound([0, 240])),

        barChart()
          .dimension(start)
          .dim_name('Date')
          .group(starts)
          .round(d3.timeDay.round)
        .x(d3.scaleTime()
          .domain([new Date(2017, 0, 24), new Date(2017, 3, 3)])
          .rangeRound([0, 300]))


    ]


    var chart = d3.selectAll(".chart")
                  .data(charts)
    
    var all_charts = d3.selectAll(".chart")
                  .on('click', function(d) {
               
                    update_selected_chart(d3.select(this));
                    
                  });
    var action_hierarchy = {},
        current_level;

        action_hierarchy.general_actions = ['addToCart', 'removeFromCart', 'purchase', 'search', 'pageview']
    current_level = action_hierarchy.general_actions;

                 
    renderAll();

    //=========================== Node Link =====================================//

    var nl_margin = {top: 20, right:20, bottom: 20, left: 20},
        nl_svg = d3.select("#node_link").append("svg")
                    .attr("width", 400)
                    .attr("height", 250),
        nl_width = +nl_svg.attr("width")- nl_margin.right - nl_margin.left,
        nl_height = +nl_svg.attr("height")- nl_margin.top - nl_margin.bottom;

    var nl_graph = nl_svg.append("g")
                    .attr("transform", "translate(" + nl_margin.left + "," + nl_margin.top + ")"),
        nl_link = nl_graph.append("g").attr("stroke", "#000").attr("stroke-width", 1.5)
                      .attr("class", "links").selectAll(".link"),
        nl_node = nl_graph.append("g").selectAll(".node");



    var color = d3.scaleOrdinal(d3.schemeCategory20),
        nl_graph_data = {nodes:[], links: []};

    var nl_simulation = d3.forceSimulation(nl_graph_data.nodes)
        // .force("link", d3.forceLink(nl_graph_data.links).distance(200))
        .force("link", d3.forceLink().id(function(d) {return d.id;}).distance(80))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(nl_width / 2, nl_height/2))
        //.alphaTarget(1)
        //.on("tick", ticked);

    //build the arrow
    nl_graph.append("svg:defs").selectAll("marker")
          .data(["end"])      // Different link/path types can be defined here
        .enter().append("svg:marker")    // This section adds in the arrows
          .attr("id", String)
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 20)
          .attr("refY", 0)
          .attr("markerWidth", 4)
          .attr("markerHeight", 4)
          .attr("orient", "auto")
          .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "gray");

    

    

    function draw_action_transition_graph(node_link_data){
      draw_node_link(node_link_data);
    }
    
    

    
        

    function draw_node_link(node_link_data){

      var node_radius = 8;

      //var node = nodes.selectAll("g").data(node_link_data.nodes);
      nl_node = nl_node.data(node_link_data.nodes, function(d) {return d.id;});

      nl_node.exit().remove();

      var node_enter = nl_node.enter().append("g")
        .on('click', select_action_node)
        // .call(d3.drag()
        //   .on("start", dragstarted)
        //   .on("drag", dragged)
        //   .on("end", dragended));
        
      node_enter.append('circle')
          .attr("r", node_radius)
          .attr("fill", function(d) { return color(d.group); })
      
      node_enter.append('text')
          .style('fill', 'black')
          .style("font-size", "10px")
          .style("text-anchor", "middle")
          .attr('dy', node_radius/2 )
          .text(function(d) {return d.action;})


      node_enter.append("title") 
          .text(function(d) { return d.id; })

      nl_node = node_enter.merge(nl_node)
                
      nl_node.select('circle')
          .attr('stroke', function(d) { return d.selected? 'black' : 'none' })
      

      //var strokeScale = d3.scaleLinear().domain([0,100]).range([1,5]);

      nl_link = nl_link.data(node_link_data.links);
      nl_link.exit().remove();


      var link_enter = nl_link.enter().append("line")
          .attr("stroke-width", function(d) { 
            //return Math.sqrt(d.value);
            return 2; 

            //return strokeScale(d.value);
          })
          .attr("marker-end", "url(#end)");

      nl_link = link_enter.merge(nl_link);

      
      


      nl_simulation
          .nodes(node_link_data.nodes)
          .on("tick", ticked);


      nl_simulation.force("link")
          .links(node_link_data.links)

      nl_simulation.alpha(1).restart();
      //simulation.restart()

      function ticked() {
        //link_enter
        nl_link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        //node_enter.selectAll('circle')
        nl_node.selectAll('circle')
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        //node_enter.selectAll('text')
        nl_node.selectAll('text')
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; });
      }

      

    }

    function dragstarted(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;

    }

    function dragged(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragended(d, simulation) {
      if (!d3.event.active) simulation.alphaTarget(0);
      // d.fx = null;
      // d.fy = null;
    }

    function reduceInitial_concat() {
        return {
            str: ''
        };
      }

      function reduceAdd_concat(p, v) {
          
          p.str = p.str + '0' + v.general_actions + '1';
        
        return p;

      }

      function reduceRemove_concat(p, v) {
        var index = p.str.length - (v.general_actions.length + 2)

        p.str = p.str.substring(0, index)
        
        return p;

      }

    function get_previous_char(str, char){
      var regex = '[^' + char + ']' + '(?=' + char + ')',
          re = new RegExp(regex, 'g'),
          matches = str.match(re);

      

      return matches;
    }

    function get_next_char(str, char){
      var regex = '' + char + '' + '([^' + char + '])' ,
          re = new RegExp(regex, 'g'),
          matches = str.match(re);

      
      new_matches = [];
      if (matches){
        matches.forEach(function(m){
          new_matches.push(m[1]);
        })
      }


      return new_matches;
    }



    function update_action_transition_graph(){
      
      var node_link_data;

      node_link_data = clear_node_link_data();
      draw_action_transition_graph(node_link_data);

      node_link_data = update_node_link_data();
      draw_action_transition_graph(node_link_data);

    }

    function clear_node_link_data(){

      nl_graph_data.nodes = [];
      nl_graph_data.links = [];

      return nl_graph_data;


    }

    function link_exists(links, source, target){

      for (var i=0; i <links.length; i++){
        var l = links[i];
        if((l.source == source) && (l.target == target))
          return l;
      }

      return null;
      

    }

    function update_link_data(action_string, links, pageFunction, reverse){

      var reverse = reverse || false;
      //create edges
      for ( var i =0; i < current_level.length; i++){
        var action = current_level[i],
            char = alphabet[action];

            source = action;

        //console.log('Action: '+ action + ' Char: ' + char);

        var matches = pageFunction(action_string, char);
        
          if (matches){ 
            var total_matches =  matches.length;
            counts = _.countBy(matches, function(char){
              return char;
            });

            for (var c in counts) {
              if (counts.hasOwnProperty(c)) {
                var target = alphabet_rev[c],
                    count = counts[c];
                    value = count*100/total_matches;

                
                if (reverse){
                  var link = link_exists(links, target, source);
                  
                  if(link){
                    link.into_target_percent = value;
                    //link.into_target_count = count;
                  }else{
                    console.log('WEIRD! link not found for reverse')
                  }
                }else{

                  links.push({source:source, target:target, percent:value, count:count});
                  
                }
              }
            }
          }
      }

      return links;
    }

    function update_node_link_data(){
      // var nl_nodes = [],
      //   nl_links = [];
      var action_string;
      

      var nodes =[],
          links = [];


      action_string = all.reduce(reduceAdd_concat, reduceRemove_concat, reduceInitial_concat).value().str;    
      //create nodes
      nodes.push({id:"start", action:"start", group:1, fx: nl_width/2, fy: 0});
      nodes.push({id:"exit", action: "exit", group:0, fx: nl_width/2, fy: nl_height});

      for ( var i =0; i < current_level.length; i++){
        var action = current_level[i];
        nodes.push({id:action, action:action, group:i+2});
      }

      current_level.push("start");

      update_link_data(action_string,links, get_next_char);
      current_level.pop();

      current_level.push("exit")
      update_link_data(action_string,links, get_previous_char, true);
      current_level.pop();


      nl_graph_data.nodes = nodes;
      nl_graph_data.links = links;




      return nl_graph_data;
      
      
    }


    function select_action_node(d){
      var links = nl_graph_data.links,
          before_links =[],
          after_links= [];
      if (selected_action_node){
        selected_action_node.selected = false;
      }
      selected_action_node = d;
      d.selected = true;
      if (pressed){
        
        if(pattern_data.nodes.length>0){
          //add link to previously added node
          previous_node_id = selected_pattern_node.id;
          add_action_node();
          current_node_id = selected_pattern_node.id;
          pattern_data.links.push({"source": previous_node_id, "target": current_node_id, "value": 0.5});
          draw_pattern_graph(pattern_data);

        }else{
          add_action_node();
        }




      }



      update_adjacency_chart_data(links);
      console.log("Selected action node: ", selected_action_node);


      draw_action_transition_graph(nl_graph_data);
      
      

    }
    

    var bar_width = 15,
        bar_length = 200;
        // bar_length = 100;

    var bar_len = d3.scaleLinear()
              .rangeRound([0, bar_length]);

    var margin_hc = {top: 20, right: 20, bottom: 30, left: 20},
      width_hc = 300 - margin_hc.left - margin_hc.right,
      height_hc = 150 - margin_hc.top - margin_hc.bottom,
      adjacency_chart = d3.select("#adjacency_chart").append('svg').append("g").attr("transform", "translate(" + margin_hc.left + "," + margin_hc.top + ")");

      adj_node = adjacency_chart.append("g")
                      .attr("transform", "translate(" + bar_length/2 + "," + (height_hc+8)/2 + ")");
                      //.attr("transform", "translate(" + (width_hc+8)/2 + "," + (height_hc+8)/2 + ")");

      adj_node.append("circle")

      adj_node.append('text')

              

                      



    function update_adjacency_chart_data(links){

     
      // var after_data={type:'after', actions:[], y:245},
      //     before_data ={type:'before', actions:[], y:0},
      var after_data={type:'after', actions:[], y:height_hc},
          before_data ={type:'before', actions:[], y:0},
          chart_data =[before_data, after_data],
          x0 = 0,
          total= 0;



      links.forEach(function(l){

        if (l.source == selected_action_node){
          //after_links.push(l);
          after_data.actions.push({action: l.target.action, group: l.target.group, count:l.count, percent: l.percent});

        }else if (l.target == selected_action_node){
          //before_links.push(l);
          before_data.actions.push({action: l.source.action, group: l.source.group, count:l.count, percent: l.into_target_percent});
        }
        

      })

      console.log('BEFORE', before_data);
      console.log('AFTER', after_data);



      update_adjacent_action_chart(chart_data)
      


    }


    function update_adjacent_action_chart(chart_data){

      

      chart_data.forEach(function(bar_data){

        var x0 = 0,
          total = 0;

        data = bar_data.actions;

        data = data.sort(function(a,b) {return b.count - a.count});
        data.forEach(function(d){
          d.x0 =x0, 
          d.x1= x0+= +d.percent;
          total += d.count;


        })
        bar_data.total = total;

      })

      

      console.log(data);
      console.log(node_radius)


      bar_len.domain([0,100]);

      adj_node.select('circle')
            .attr("r",node_radius)
            .style("fill", color(selected_action_node.group))

      adj_node.select('text')
            .style("font-size", "10px")
            .style("text-anchor", "middle")
            .style('fill', 'black')
            .text(selected_action_node.action)


         //drawing chart
      var bar = adjacency_chart
          .selectAll(".adjbar")
              .remove()
              .exit()
              .data(chart_data)
              .enter().append("g")
              .attr("class", "adjbar")
              .attr("transform", function (d) { return "translate(0," + d.y + ")"; })
              //.attr("transform", function (d) {console.log('d.y', d.y); return "translate(" + d.y + ",0)"; })


              
     var bar_enter = bar.selectAll("rect")
          .remove()
          .exit()
          .data(d =>d.actions)
          .enter();

        bar_enter.append("rect")
              .attr("x", function(d){
                  return bar_len(d.x0);
              })
              .attr("height", function(d){
                  return bar_width;
              })
              .attr("width", function(d){
                  return bar_len(d.x1) - bar_len(d.x0);
              })
              .attr("fill", function(d) {return color(d.group);});

        // bar_enter.append("rect")
        //       .attr("y", function(d){
        //           return bar_len(d.x0);
        //       })
        //       .attr("width", function(d){
        //           return bar_width;
        //       })
        //       .attr("height", function(d){
        //           return bar_len(d.x1) - bar_len(d.x0);
        //       })
        //       .attr("fill", function(d) {return color(d.group);});



    }

    function select_pattern_node(d){
      if (selected_pattern_node){
        selected_pattern_node.selected = false;
      }
      selected_pattern_node = d;
      d.selected = true;
      console.log('selected pattern node:', selected_pattern_node);
      

      var links = pattern_data.links,
          before_links =[],
          after_links = [];


      


      draw_pattern_graph(pattern_data);


    }

    // ========================== Pattern Builder ============================== //
    var node_radius = 8;
    var pb_margin = {top: 20, right:20, bottom: 20, left: 20},
        pb_svg = d3.select("#pb_graph").append("svg")
                    .attr("width", 200)
                    .attr("height", 250),
        pb_width = +pb_svg.attr("width")- pb_margin.right - pb_margin.left,
        pb_height = +pb_svg.attr("height")- pb_margin.top - pb_margin.bottom;

    var pb_graph = pb_svg.append("g")
                    .attr("transform", "translate(" + pb_margin.left + "," + pb_margin.top + ")"),
        // pb_link = pb_graph.append("g")
        //               .attr("class", "links"),
        // pb_node = pb_graph.append("g");

        pb_link = pb_graph.append("g").attr("stroke", "#000").attr("stroke-width", 1.5)
                      .attr("class", "links").selectAll(".link"),
        pb_node = pb_graph.append("g").selectAll(".node");

    var pattern_data = {nodes:[], links: []},
        selected_pattern_node;

    var pb_simulation = d3.forceSimulation(pattern_data.nodes)
        .force("link", d3.forceLink().id(function(d) {return d.id;}).distance(10))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(pb_width / 2, pb_height/2))
        //.alphaTarget(1)

        pb_graph.append("svg:defs").selectAll("marker")
          .data(["end"])      // Different link/path types can be defined here
        .enter().append("svg:marker")    // This section adds in the arrows
          .attr("id", String)
          .attr("viewBox", "0 -5 10 10")
          .attr("refX", 20)
          .attr("refY", 0)
          .attr("markerWidth", 4)
          .attr("markerHeight", 4)
          .attr("orient", "auto")
          .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "gray");

    

    function add_action_node(){
      if (selected_action_node){
        console.log(selected_action_node);
        new_node = {
          action: selected_action_node.action,
          id: selected_action_node.id,
          group: selected_action_node.group
        }
        if (pattern_data.nodes.length == 0){
          new_node.fx = pb_width/2;
          new_node.fy = 0;
        }

        selected_pattern_node = new_node;
        pattern_data.nodes.push(new_node);
        draw_pattern_graph(pattern_data);
      }
      else
        console.log('Please select node to add!')
    }

    function remove_action_node(d){
      //ONLY WORKS FOR FUNNEL
      if (selected_pattern_node){
        var nodes = pattern_data.nodes,
            links = pattern_data.links,
            idx = nodes.indexOf(selected_pattern_node);

        //assumes nodes and links were added in order
        nodes.splice(idx);

        for(var i=0; i<links.length; i++){
          var l = links[i];
          if (l.target == select_pattern_node){
            idx = i;
            break;
          }
        }

        links.splice(idx-1);

        console.log('index of remove', idx);
        console.log('new nodes', pattern_data.nodes);

        draw_pattern_graph(pattern_data);
      }else{
        alert('Please select node to remove!');
      }


    }


    var pressed= false;

    function create_funnel(){
      toggle_button_color("#create_funnel_button");
      pressed = !pressed;
      d3.select("#create_funnel_button").text(function(d){return pressed? 'Complete Funnel': 'Create Filter'});

      if (!pressed){
        create_funnel_regex()
      }









    }

    function create_funnel_regex(){
      var nodes = pattern_data.nodes,
          regex = '.*';

      nodes.forEach(function(n){
        regex = regex + alphabet[n.id]; + '.*';

      })
    }


    function apply_funnel(){

      var nodes = pattern_data.nodes,
          regex = '.*',
          chars= [],
          filters = [],
          parent = selected;

      nodes.forEach(function(n){
        regex = regex + alphabet[n.id] + '.*';
        console.log('regex', regex);
        chars.push(alphabet[n.id]); 
        var match = all.reduce(reduceAdd,reduceRemove, reduceInitial).value();
        if (match){
          var size = match.count,
              filter = {};

          selectedFilter.chart = selected_chart;
          selectedFilter.size = size;
          selectedFilter.type = 'regex';
          selectedFilter.char = chars.slice();

          console.log('creating filter:', selectedFilter);

          selectedFilter.div = "action_strings";

          var filter = create_filter(parent);

          parent = filter.children[0];

        }

      })

      function reduceInitial() {
        return {
            count: 0
        };
      }

      function reduceAdd(p, v) {
        if (v.general_actions.match(regex))
          p.count = p.count + 1;
        
        return p;

      }

      function reduceRemove(p, v) {
        if (v.general_actions.match(chars))
          p.count = p.count - 1;
        
        return p;

      }



    }


    function draw_pattern_graph(node_link_data){

      console.log('draw PATTERN graph with data:', node_link_data);

      

      pb_node = pb_node.data(node_link_data.nodes, function(d) {return d.id;});

      pb_node.exit().remove();

      var node_enter = pb_node.enter().append("g")
        .on('click', select_pattern_node)
        .call(d3.drag()
          .on("start", function(d){ return dragstarted(d, pb_simulation);})
          .on("drag", function(d){ return dragged(d, pb_simulation);})
          .on("end", function(d){ return dragended(d, pb_simulation);}))
        
      node_enter.append('circle')
          .attr("r", node_radius)
          .attr("fill", function(d) { return color(d.group); })
      
      node_enter.append('text')
          .style('fill', 'black')
          .style("font-size", "10px")
          .style("text-anchor", "middle")
          .attr('dy', node_radius/2 )
          .text(function(d) {return d.action;})


      node_enter.append("title") 
          .text(function(d) { return d.id; })

      pb_node = node_enter.merge(pb_node)
                
      pb_node.select('circle')
          .attr('stroke', function(d) { return d.selected? 'black' : 'none' })
      

      //var strokeScale = d3.scaleLinear().domain([0,100]).range([1,5]);

      pb_link = pb_link.data(node_link_data.links);
      pb_link.exit().remove();


      var link_enter = pb_link.enter().append("line")
          .attr("stroke-width", function(d) { 
            //return Math.sqrt(d.value);
            return 2; 

            //return strokeScale(d.value);
          })
          .attr("marker-end", "url(#end)");

      pb_link = link_enter.merge(pb_link);

      
      


      pb_simulation
          .nodes(node_link_data.nodes)
          .on("tick", ticked);


      pb_simulation.force("link")
          .links(node_link_data.links)

      //pb_simulation.alpha(1).restart();
      pb_simulation.restart();

      function ticked() {
        //link_enter
        pb_link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        //node_enter.selectAll('circle')
        pb_node.selectAll('circle')
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        //node_enter.selectAll('text')
        pb_node.selectAll('text')
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; });
      }

      

    }
    






    //=========================== Info Views ====================================//

    function update_info_view(view_id){
      view_id = view_id || null;
      active_view = view_id;
      d3.selectAll(".info")
        .style('display', function(d) {
          var id = d3.select(this).attr('id');
          if (id != active_view)
            return 'none';
        });
    }

    //------------ Node view ------------- //

    var activeview;
    var text_object = [];

    function show_node_view(selected){
      var d = selected.data;
      if (d.value == 1){
        update_info_view("segment_view");
        get_segment_info(selected);
      }else if(d.value == 0){
        update_info_view("filter_view")
        get_filter_info(selected);
      }else if(d.value == 2){
        update_info_view("partition_view")
        get_partition_info(selected);
      }

    }


    function update_text(view, text_format) {

      var selection = view.selectAll('.filterText')
                  .data(text_object)

      selection.enter()
        .append('text')
        .attr('class', 'filterText')
        .attr("dy", function(d,i){ return i+2 +"em";})
        .style("font-size", "10px")
        .style("text-anchor", "left")
        .style('fill', 'black')
        .text(text_format)

      selection.exit().remove();


    }

     var nv_margin = {top: 20, right:20, bottom: 20, left: 20},
      nv_width = 500 - nv_margin.right - nv_margin.left,
      nv_height = 200 - nv_margin.top - nv_margin.bottom;

    

    //----------- Filter View -------------- //
    var fv_svg = d3.select("#filter_view")
                    .append("svg")
                    .attr("width", nv_width + nv_margin.left + nv_margin.right)
                    .attr("height", nv_height + nv_margin.top + nv_margin.bottom),
                    //.attr("transform", "translate(" + pv_margin.left + "," + pv_margin.top + ")");
                    
    filter_view = fv_svg.append("g")
                      .attr("transform", "translate(" + nv_margin.left + "," + nv_margin.top + ")")


    function get_filter_info(selected){
      var d = selected.data,
          filter_info = d.filter_type,
          chart = filter_info.chart;

      update_selected_chart(chart);

      text_object = [];
      update_filter_text(filter_view);
      text_object.push(filter_info);
      update_filter_text(filter_view);
      

    }

    function format_filter_text(d){
      var values="";
      if (d.type=="range")
        values = d.extents;
      else if (d.type =="contains")
        values = alphabet_rev[d.char];
      return d.chart.attr('id') + ": " + d.type +" -> [" + values + ']';
    }

    

    function update_filter_text(view){
      update_text(view, format_filter_text);
    }


    // --------------- Partition View --------------------- //

    var pv_svg = d3.select("#partition_view")
                    .append("svg")
                    .attr("width", nv_width + nv_margin.left + nv_margin.right)
                    .attr("height", nv_height + nv_margin.top + nv_margin.bottom),
                    //.attr("transform", "translate(" + pv_margin.left + "," + pv_margin.top + ")");
                    
    partition_view = pv_svg.append("g")
                      .attr("transform", "translate(" + nv_margin.left + "," + nv_margin.top + ")")
    pv_chart_title = partition_view.append('g')
                    .append('text').attr('class', 'gtitle')
                  .style("font-size", "10px")
                  .style("text-anchor", "left")
                  .style('fill', 'black')
                  .text('Chart used in partition: ' + chart.attr('id'))
                      

    pv_partitions = partition_view.append("g")
                      .attr("transform", "translate(" + 0 + "," + 20 + ")");
    
    pv_partitions.append('g').append('text')
          .style("font-size", "10px")
          .style("text-anchor", "left")
          .style('fill', 'black')
          .text('Partitions: ')

    partition_list = pv_partitions.append('g')
          .attr("transform", "translate(" + 5 + "," + 0 + ")");               

    function get_partition_info(selected){

      var d = selected.data,
          partitions = d.partitions,
          chart = d.chart;

      update_selected_chart(chart);
      
      d3.selectAll('.gtitle').text('Chart used in partition: ' + chart.attr('id'));


      
      text_object = [];
      update_partition_text(partition_list);
      text_object = partitions;
      update_partition_text(partition_list);
      

    }


    function format_partition_text(d){

      return 'range: [' + d.range[0] + ', ' + d.range[1] + '],' + '    # of seqs: ' + d3.format(",")(d.size) + ',    % of seqs: ' + d3.format(".1%")(d.percent);

    }
    
    function update_partition_text(view){
      update_text(view, format_partition_text);
    }

    // -------- Segment View ------------- //
    var sv_svg = d3.select("#segment_view")
                    .append("svg")
                    .attr("width", nv_width + nv_margin.left + nv_margin.right)
                    .attr("height", nv_height + nv_margin.top + nv_margin.bottom),
                    
        segment_view = sv_svg.append("g")
                          .attr("transform", "translate(" + nv_margin.left + "," + nv_margin.top + ")"),
        sv_filters = segment_view.append("g")
                      .attr("transform", "translate(" + 0 + "," + 60 + ")"),
        //sv_filters = d3.select('#sv_filters').append('g');
        sv_sizes = segment_view.append("g");
        //sv_sizes = d3.select('#sv_size').append('g')
    sv_sizes.append('g').append('text')
          .style("font-size", "12px")
          .style("text-anchor", "left")
          .style('fill', 'black')
          .text('Size: ')


    size_list = sv_sizes.append('g')
          .attr("transform", "translate(" + 5 + "," + 0 + ")");


    sv_filters.append('g').append('text')
          .style("font-size", "12px")
          .style("text-anchor", "left")
          .style('fill', 'black')
          .text('Filters: ')

    filter_list = sv_filters.append('g')
          .attr("transform", "translate(" + 5 + "," + 0 + ")");



    function get_segment_info(selected) {
      var d = selected.data,
          filters = d.filters;

      var size = d3.format(",")(d.size),
          rel = d3.format(".1%")(d.size/total_size),
          abs = d3.format(".1%")(d.size/original_size);

      sizes = ["Number of seqs: "+ size, "Percent of total: " + abs, "Percent of previous: " + rel]

      text_object = [];
      update_filter_text(filter_list);
      update_size_text(size_list);

      text_object = sizes;
      update_size_text(size_list);

      
      if (filters){
        text_object = filters;
        update_filter_text(filter_list);
      }

    }

    function format_size_text(d){

      return d;

    }
    
    function update_size_text(view){
      update_text(view, format_size_text);
    }




    //------------ Partition view ------- //

    var pv_margin = {top: 20, right:20, bottom: 20, left: 20},
      pv_width = 500 - pv_margin.right - pv_margin.left,
      pv_height = 200 - pv_margin.top - pv_margin.bottom;

    var pv_svg = d3.select("#create_partition_view")
                    .append("svg")
                    .attr("width", pv_width + pv_margin.left + pv_margin.right)
                    .attr("height", pv_height + pv_margin.top + pv_margin.bottom)
                    //.attr("transform", "translate(" + pv_margin.left + "," + pv_margin.top + ")");
                    
        partition_view = pv_svg.append("g")
                      .attr("transform", "translate(" + pv_margin.left + "," + pv_margin.top + ")");

     var x_range, 
        selected_partition_bar,
        barId= 1,
        range_bar = partition_view.append("g")
          .attr("transform", "translate(" + 0 + "," + pv_height/2 +")")
          .attr("class", "axis"),

        partitions = [];

    var partition_input = d3.select("#partition_value")
              

        partition_input.on("input", function(){
                set_partition_value(this.value);
                })

    function show_partition_view() {
      //d3.select("#create_partition_view").style("display", "block");
      update_info_view("create_partition_view");
      update_partition_view();
    }

    function set_partition_value(value){
      if (selected_partition_bar){
        selected_partition_bar.value = value;
        selected_partition_bar.x = x_range(value);
        update_partition_bars();
      }else {
        alert('Select partition bar first');
      }

    }
    function add_partition_bar(x_location){
      x_location = x_location || 0;
      //artitions.forEach(function(p){p.selected = false;})
      var new_partition = {'id': barId++, 'x': x_location, 'value': x_range.invert(x_location)}
      select_partition_bar(new_partition);
      partitions.push(new_partition);
      update_partition_bars();

    }

    function remove_partition_bar(){
      var remove_index;

      console.log('the selected partition', selected_partition_bar)

      for(var i = 0; i < partitions.length; i++){
        var p = partitions[i];
        if (p.id == selected_partition_bar.id)
          remove_index = i;
      }

      if (remove_index > -1){
        partitions.splice(remove_index,1);
        update_partition_bars();
      }else {
        alert('Please select partition bar to remove')
      }


    }

    function select_partition_bar(d){
      if (selected_partition_bar)
          selected_partition_bar.selected = false;
        selected_partition_bar = d;
        d.selected = true;
        //partition_input.attr('value', selected_partition_bar.value);
        partition_input.property("value", selected_partition_bar.value)
        update_partition_bars();
    }

    function update_partition_bars() {


      d3.selectAll(".partition").remove(); 
      var range_partition = range_bar.selectAll('g.partition')
                                .data(partitions)
                                .enter()
                                .append('g')
                                .attr('class', 'partition')
                                // .attr("transform", function(d) { return "translate(" + d.x + "," + 0 + ")"; })
                                .call(d3.drag()
                                  .on("start", dragstarted)
                                  .on("drag", dragged)
                                  .on("end", dragended));
      var partition_width = 4,
          partition_height = 30;

      range_partition.append('rect')
      .attr('class', 'partition')
      .attr('width', partition_width)
      .attr('height', partition_height)
      .attr('x', function(d){return d.x})
      .attr('y', -(partition_height/2))
      .attr('stroke', function(d) { return d.selected? 'black' : 'none' })
      .on('click', select_partition_bar)
      
      range_partition.append('text')
        .attr("dy", ".15em")
        .attr("y", function(d) { return -(partition_height/2)-3; })
        .attr('x', function(d){return d.x + 2})
        .style("font-size", "10px")
        .style("fill", "black")
        .style("text-anchor", "middle")
        .text(function(d) { 
            var value = x_range.invert(d.x);
            if (typeof value =='number')
              return Math.floor(value);
            else
              return value;

          })

      function dragstarted(d) {
        d3.select(this).raise().classed("active", true);
      }

      function dragged(d) {
        if (!d.selected){
          select_partition_bar(d);
        }
        var event = d3.event.x;
        var x_loc = event;
        if (event < 0)
          x_loc = 0;
        else if (event > pv_width)
          x_loc = pv_width;

        if (typeof x_range.domain()[0] == 'number'){
          x_loc = x_range(Math.round(x_range.invert(x_loc)));
        }

        d3.select(this).select("rect").attr("x", function(d)  {return d.x = x_loc;});
        d3.select(this).select("text")
            .text(function(d) {
              d.value = x_range.invert(d.x)
              if (typeof d.value =='number')
                return Math.floor(d.value);
              else
                return d.value;})
            .attr("x", function(d)  {return d.x = x_loc;});
         partition_input.property("value", selected_partition_bar.value);
      }

      function dragended(d) {
        d3.select(this).classed("active", false);
      }

    }
    

    function update_partition_view(){

     //render selected chart
     console.log('in update partition view, selected chart: ', selected_chart.node());
     console.log('in update partition view, selected chart: ', selected_chart.data());

     if (selected_chart.data()[0]){

       selected_chart.call(selected_chart.data()[0]);


        if (chart_range){
          if(typeof chart_range[0] == "number")
            x_range = d3.scaleLinear().range([0,pv_width])
          else
            x_range = d3.scaleTime().range([0,pv_width])
          
          range_axis = d3.axisBottom(x_range)
                      .ticks(5)  
          x_range.domain(chart_range);
          range_bar.call(range_axis);

          partitions =[];
          
          add_partition_bar(pv_width*0.25);
          add_partition_bar(pv_width*0.75);

          partition_bars = d3.selectAll(".partition");


        }

     } else {
      alert('Choose another chart to partition!');
     }

    }

    //----------- end of partition view ----------//

    function update_selected_chart(div) {
     
      if (selected_chart)
        selected_chart.style("background-color", "white" );
      selected_chart = div;
      selected_chart.style("background-color", "lightyellow" );

      if (active_view == 'create_partition_view')
        update_partition_view();

    }

    function render(method) {
      d3.select(this).call(method);
    }

    function renderAll() {
      chart.each(render);
      
    }


    window.filter = filters => {
      filters.forEach((d, i) => { charts[i].filter(d); });
      renderAll();
    };

    window.reset = function(i) {
      charts[i].filter(null);
      selectedFilter={};
      renderAll();
    };


    function get_x_limit(groups, yScale) {

      for (var i= groups.length -1 ; i >= 0 ; i--){
        var grp = groups[i];
        var pixels = yScale(0) - yScale(grp.value);

        if (pixels > 1){
          var x_domain_max;
          if (i == groups.length -1)
            x_domain_max = null;
          else
            x_domain_max = grp.key + 2;
          break;
        }

      }

      return x_domain_max;
    }
    
    function reduce_leftover_count(x_max, groups){
      var leftover_count = 0;

      if (x_max){
        x_max = x_max - 1;
        var idx = groups.length-1;
        grp = groups[idx];

        while (grp.key > x_max){
          leftover_count = leftover_count + grp.value
          idx = idx - 1;
          grp = groups[idx]; 
        }

        return leftover_count;

      } 

      return 0;
    }

  function get_chart_range(groups){

    var idx = 0,
        n = groups.length,
        grp = groups[idx];

    while (grp.value == 0 && idx < (n-1)){
      //x_min = grp.key;
      idx = idx+1;
      grp = groups[idx];
    }
    x_min = grp.key;

    var idx = n-1;
        grp = groups[idx];

    while (grp.value == 0 && idx >= 0){
      // x_max = grp.key;
      idx = idx - 1;
      grp = groups[idx]; 
    }
    x_max = grp.key;


    return [x_min, x_max];
  }


  function barChart() {
      if (!barChart.id) barChart.id = 0;

      var margin = {top: 10, right: 13, bottom: 35, left: 55},
          x,
          y = d3.scaleLinear().range([100, 0]),
          id = barChart.id++,
          axis = d3.axisBottom(),
          axisY = d3.axisLeft(),
          brush = d3.brushX(),
          x_domain_max,
          x_max,
          x_min,
          brushDirty,
          leftover_count,
          dim_name,
          dimension,
          group,
          round;
      

      function chart(div) {
        var width = x.range()[1],
           height = y.range()[0];

        brush.extent([[0,0], [width, height]]);
        

        div.each(function() {
          var div = d3.select(this),
              g = div.select("g");

          
      

          // Create the skeletal chart.
          if (g.empty()) {
            
            chart_data[div.attr('id')].id = id;
            y.domain([0, group.top(1)[0].value]);

            x_domain_max = get_x_limit(group.all(), y);
            x_max = group.all()[group.all().length-1].key;
            // x_min = group.all()[0].key;
      
            if (x_domain_max){
              x.domain([x.domain()[0], x_domain_max]);
              x.range([0, x_domain_max*10])

              width = x.range()[1];
              brush.extent([[0,0], [width, height]]);
              margin.right = 30;
              
              if (x_domain_max < 5)
                axis.ticks(x_domain_max);
              
              axis.scale(x);
            }
            

            div.select(".title").append("a")
                .attr("href", "javascript:reset(" + id + ")")
                .attr("class", "reset")
                .text("reset")
                .style("display", "none");



            g = div.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
              .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            

            leftover_x = width + margin.right - 18
            g.append("rect")
                    .attr("class", "leftovers")
                    .attr("id", "leftovers")
                    .attr("x", leftover_x)
                    // .attr("y", height - leftover_height)
                    // .attr("height", leftover_height)
                    .attr("width", 9)
                    .on("click", function(d) {

                       var extents = [x_domain_max, x_max+1];
                       update_selected_chart(div);

                       selectedFilter.chart = selected_chart;
                       selectedFilter.div = div.attr('id');
                       selectedFilter.extents = extents;
                       selectedFilter.type = 'range';
                       
                       leftover_count = reduce_leftover_count(x_domain_max, group.all());
                       selectedFilter.size = leftover_count
                      update_selected_bar(d3.select(this));
                    })
            g.append("text")
              .attr("y", height+2)
              .attr("x", leftover_x)
              .attr("dy", "1em")
              .style("text-anchor", "left")
              .style("font-size", "8px")
              .style("fill","black")
              .text(function(d) { return x_domain_max? "LO" : "";});


            g.append("clipPath")
                .attr("id", "clip-" + id)
              .append("rect")
                .attr("width", width)
                .attr("height", height);

            

            g.selectAll(".bar")
                .data(["background", "foreground"])
              .enter().append("path")
                .attr("class", function(d) {return d + " bar"; })
                .datum(group.all());

            g.selectAll(".foreground.bar")
                .attr("clip-path", "url(#clip-" + id + ")");

            g.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(0," + height + ")")
                .call(axis);


            g.append("g")
                .attr("class", "axisY")
                .call(axisY);
            //set up y axis title
            g.append("text")
              .attr("transform", "rotate(-90)")
              .attr("y", 0 - margin.left)
              .attr("x",0 - (height / 2))
              .attr("dy", "1em")
              .style("text-anchor", "middle")
              .style("font-size", "10px")
              .style("fill","black")
              .text("# of Sequences"); 

            //set up x axis title
            g.append("text")             
              .attr("transform",
                    "translate(" + (width/2) + " ," + 
                                   (height + margin.top + 20) + ")")
              .style("font-size", "10px")
              .style("text-anchor", "middle")
              .style("fill","black")
              .text(dim_name);


            //Initialize the brush component with pretty resize handles.
            var gBrush = g.append("g").attr("class", "brush").call(brush);

            gBrush.selectAll('.handle--custom')
              .data([{ type: 'w' }, { type: 'e' }])
              .enter().append('path')
                .attr('class', 'brush-handle')
                .attr('cursor', 'ew-resize')
                .attr('d', resizePath)
                .style('display', 'none');
          }

          if (brushDirty !== false) {
            const filterVal = brushDirty;
            brushDirty = false;

            div.select('.title a').style('display', d3.brushSelection(div) ? null : 'none');

            if (!filterVal) {
              g.call(brush);

              g.selectAll(`#clip-${id} rect`)
                .attr('x', 0)
                .attr('width', width);

              g.selectAll('.brush-handle').style('display', 'none');
              renderAll();
            } else {
              const range = filterVal.map(x);
              brush.move(gBrush, range);
            }
          }

          var leftover_count = reduce_leftover_count(x_domain_max, group.all());
          //var leftover_height = 100 - y(leftover_count);
          x_max = group.all()[group.all().length-1].key;
          x_min = group.all()[0].key;

          // if (x_domain_max)
          //   chart_range = [x_min, x_domain_max]
          // else
            //chart_range = [x_min, x_max]

          chart_range = get_chart_range(group.all());

          if (new_selection){

              y_max = group.top(1)[0].value;
              new_y_max = leftover_count > y_max ? leftover_count : y_max;

              y.domain([0, new_y_max]);
              t1 = g.transition().duration(1000);
              
              t1.selectAll(".bar").attr("d", barPath);
              t1.selectAll(".axisY").call(axisY);

              if (x_domain_max){
                t1.select('#leftovers')
                  .attr("height", height - y(leftover_count))
                  .attr("y", y(leftover_count));
              }


              

            } else {



              g.selectAll(".bar").attr("d", barPath);
              if (x_domain_max){
                g.select('#leftovers')
                  .attr("height", height - y(leftover_count))
                  .attr("y", y(leftover_count));
              }
              
            }
            


          
        });

        function leftoverPath(leftover_height){
          return "M" + (width+18) + "," + height + "V" + y(leftover_height) + "h" + 9 + "V" + height;
        }

        function barPath(groups) {
          var path = [],
              i = -1,
              n = groups.length,
              d;


          // if (typeof x.domain()[1] == "number"){
          //   n_groups = x.domain()[1];
          //   bar_width = Math.floor(x.range()[1]/n_groups) -0.05 
          // }
          // else
          //   bar_width = 8;
          //   //n_groups = n;
          // ;
          bar_width = 9;
          while (++i < n) {
            d = groups[i];
            //path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
            if (x_domain_max){
              if (d.key < x_domain_max)
                path.push("M", x(d.key), ",", height, "V", y(d.value), "h" + bar_width + "V", height);
            } else {
              path.push("M", x(d.key), ",", height, "V", y(d.value), "h" + bar_width + "V", height);
            }
          }

          return path.join("");
        }

        function resizePath(d) {
          var e = +(d == "e"),
              x = e ? 1 : -1,
              y = height / 3;
          return "M" + (.5 * x) + "," + y
              + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
              + "V" + (2 * y - 6)
              + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
              + "Z"
              + "M" + (2.5 * x) + "," + (y + 8)
              + "V" + (2 * y - 8)
              + "M" + (4.5 * x) + "," + (y + 8)
              + "V" + (2 * y - 8);
        }
      }

      brush.on("start.chart", function() {
        var div = d3.select(this.parentNode.parentNode.parentNode);
        update_selected_chart(div);
        //reset_filters(id);
        div.select(".title a").style("display", null);
        selectedDiv = div.attr('id');
      });

      brush.on('brush.chart', function () {
        const g = d3.select(this.parentNode);
        const brushRange = d3.event.selection || d3.brushSelection(this); // attempt to read brush range
        const xRange = x && x.range(); // attempt to read range from x scale
        let activeRange = brushRange || xRange; // default to x range if no brush range available

        const hasRange = activeRange &&
          activeRange.length === 2 &&
          !isNaN(activeRange[0]) &&
          !isNaN(activeRange[1]);

        if (!hasRange) return; // quit early if we don't have a valid range

        // calculate current brush extents using x scale
        let extents = activeRange.map(x.invert);


        // if rounding fn supplied, then snap to rounded extents
        // and move brush rect to reflect rounded range bounds if it was set by user interaction
        if (round) {
          extents = extents.map(round);
          activeRange = extents.map(x);

          if (
            d3.event.sourceEvent &&
            d3.event.sourceEvent.type === 'mousemove'
          ) {
            d3.select(this).call(brush.move, activeRange);
          }
        }

        // move brush handles to start and end of range
        g.selectAll('.brush-handle')
          .style('display', null)
          .attr('transform', (d, i) => `translate(${activeRange[i]}, 0)`);

        // resize sliding window to reflect updated range
        c = g.select(`#clip-${id} rect`)
          .attr('x', activeRange[0])
          .attr('width', activeRange[1] - activeRange[0]);



        // filter the active dimension to the range extents

    
        dimension.filterRange(extents);
        //selectedExtents = extents;
        selectedFilter.chart = selected_chart;
        selectedFilter.div = selectedDiv;
        selectedFilter.extents = extents;
        selectedFilter.type = 'range';
        selectedFilter.size = all.reduceCount().value();




        // re-render the other charts accordingly
        renderAll();
      });


       brush.on('end.chart', function () {
        // reset corresponding filter if the brush selection was cleared
        // (e.g. user "clicked off" the active range)
        if (!d3.brushSelection(this)) {
          reset(id);
          selectedFilter = {};
        }

      });

      chart.margin = function(_) {
        if (!arguments.length) return margin;
        margin = _;
        return chart;
      };

      chart.x = function(_) {
        if (!arguments.length) return x;
        x = _;
        axis.scale(x);
        axisY.scale(y).ticks(6);
        return chart;
      };

      chart.y = function(_) {
        if (!arguments.length) return y;
        y = _;
        return chart;
      };
      
      chart.dim_name = function(_) {
        if (!arguments.length) return dim_name;
        dim_name = _;
        return chart;
      };

      chart.dimension = function(_) {
        if (!arguments.length) return dimension;
        dimension = _;
        return chart;
      };

      chart.filter = _ => {
        if (!_) dimension.filterAll();
        brushDirty = _;
        return chart;
      };

      chart.group = function(_) {
        if (!arguments.length) return group;
        group = _;
        return chart;
      };

      chart.round = function(_) {
        if (!arguments.length) return round;
        round = _;
        return chart;
      };

      chart.gBrush = () => gBrush;

      return chart;
    }
     

    //});






  var data = [];                        //Initialize empty array
  for (var i = 0; i < 1000; i++) {           //Loop 25 times
      //var newNumber = Math.random() * 30;
      var newNumber = Math.round(Math.random() * 100);  //New random number (0-30)
      data.push(newNumber);             //Add new number to array
  }


  function group_count(d, thresholds) {
    
    thresholds = thresholds || [10, 2, 1, 0];

    var index = 0;
    t = thresholds[index];
    while (d < t){
      index = index + 1;
      t = thresholds[index];
    }
    
    return thresholds[index];
  }


  var margin = {top: 20, right:20, bottom: 20, left: 20},
      width = 300 - margin.right - margin.left,
      height = 750 - margin.top - margin.bottom;

  var RECT_W_max = 100,
      RECT_W_min = 1,
      RECT_H = 20,
      DEPTH = 35;


  var data0 = [
      { "name": "Root", "parent": "null", "visible":1, "value":-1},
      { "name" : "Segment A", "parent":"Root", "value":1, "visible":1 }
      ];

  total_size = all.reduceCount().value();
  data0[1].size = total_size;
  original_size = data0[1].size;

  wScale = d3.scaleLinear().domain([0,total_size]).range([RECT_W_min, RECT_W_max]);

  //var data = JSON.parse(JSON.stringify(original_data));
  original_data = JSON.stringify(data0)
  data = JSON.parse(original_data)

  var treeData = [];

  unflatten(treeData, data);


  // ************** Generate the tree diagram  *****************
  //var buttons = d3.select("#buttons")


      
  var i = 0,
      duration = 750,
      root;

  var tree = d3.tree()
        .size([width, height]);


  var svg = d3.select("#tree").append("svg")
      .attr("width", width + margin.right + margin.left)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");





  var selected,
      selected_chart,
      chart_range,
      selected_action_node;



  size = 1000;
  root = d3.hierarchy(treeData[0], function(d) { return d.children; })
  root.x0 = height / 2;
  root.y0 = 0;


  update(root);



  d3.select(self.frameElement).style("height", "500px");


  //-------------------- FUNCTIONS ---------------------

    function unflatten(treeData, data) {
        
        var dataMap = data.reduce(function(map, node) {
            map[node.name] = node;
            return map;
        }, {});

        data.forEach(function(node) {
         // add to parent
         var parent = dataMap[node.parent];
         if (parent) {
          // create child array if it doesn't exist
          (parent.children || (parent.children = []))
           // add node to child array
           .push(node);
         } else {
          // parent is null or missing
          treeData.push(node);
         }
        });
    }



    function update(source) {

      //console.log('UPDATING');
      // Compute the new tree layout.
      var treeData = tree(root);
      var nodes = treeData.descendants(),
          links = treeData.descendants().slice(1);


      // Normalize for fixed-depth. Each layer is same distant apart
      nodes.forEach(function(d) { d.y = d.depth * DEPTH; });

      // Update the nodes…
      var node = svg.selectAll("g.node")
          .data(nodes, function(d) {return d.id || (d.id = ++i); });

      // Enter any new nodes at the parent's previous position.
      var nodeEnter = node.enter().append("g")
          .attr("class", "node")
          .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
          //.on("dblclick", hide_children)
          .on("dblclick", filter_partition);

      

      nodeEnter.append("path")
            .attr('class', 'node')
            .each( format_nodes)
            .on("click", select_node)
            //.on("mouseover", show_node_view)
            // .on("mouseover", function(d){ 
            //       if (d.value != 1)
            //         select_node(d);
            //     });

      nodeEnter.append("text")
        .attr("dy", ".15em")
        .attr("y", function(d) { return d.children ? -0 : 0; })
        .style("font-size", "10px")
        .style("text-anchor", "middle")
        .text(function(d) { 
          if (d.data.value == 1)
            return d.data.size;
          else
            return ''; });
      

      // Transition nodes to their new position.
      var nodeUpdate = nodeEnter.merge(node);


      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });



      nodeUpdate.select("path").each(format_nodes)


      // Transition exiting nodes to the parent's new position.
      var nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
          .remove();


      // Update the links…
      var link = svg.selectAll("path.link")
          .data(links, function(d) { return d.id; });

      link.style("opacity", function(d){
                if(!d.data.visible && !d.children)
                    return 0;
                else
                    return 1;
                });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert("path", "g")
          .attr("class", "link")
          .attr("d", function(d) {
            var o = {x: source.x0, y: source.y0};
            return diagonal(o,o);
          })

      var linkUpdate = linkEnter.merge(link);
      // Transition links to their new position.



      linkUpdate.transition()
          .duration(function(d) {
                          return duration;
                    })
          .attr("d", function(d){return diagonal(d, d.parent)})

      // Transition exiting nodes to the parent's new position.
      var linkExit = link.exit().transition()
          .duration(duration)
          .attr("d", function(d) {
            var o = {x: source.x, y: source.y};
             // if(!d.target.visible && !d.target.children)
             //            return "M0,0";
             //        else
                        return diagonal(o,o);
                    
            
          })
          .remove();

      // Stash the old positions for transition.
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }


    function diagonal(s, d) {


        return "M" + s.x + "," + s.y
             + "C" + s.x + "," + (s.y + d.y) / 2
             + " " + d.x + "," +  (s.y + d.y) / 2
             + " " + d.x + "," + d.y;
      }



    // Toggle children on click.
    function hide_children(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      update(d);
    }

    function format_nodes(d, i) {

        d = d.data
        n = node_types[d.value];

        if (d.visible) 
          size = n.size;
        else
          size = 0;

        shape = n.shape;

        d3.select(this)
            .attr("d", function(d) {
                        if (d.value == 1)
                          return create_rect_path(d);
                        else
                          return d3.symbol().size(size).type(function(d) {

                            if (n.shape == "diamond")
                              return d3.symbolDiamond;
                            else if (n.shape == "triangle-down")
                              return d3.symbolTriangle;
                            else 
                              return d3.symbolCircle;

                          })

                        ();
                      })
            .style("stroke", function(d) { return d.selected ? "black" : n.stroke;})
            .style("fill", n.fill)
            .style("stroke-width", n.stroke_width);


    }

    function reset_filters(exception) {

      l.filterAll();
      h.filterAll();
      hour.filterAll();
      len.filterAll();
      action_strings.filterAll();

      max_id = 3
      exception = exception || -1;
      for(var i=0; i<= max_id; i++){
        if (i != exception)
          reset(i);


      }


    }
    var dim;
    function select_node(d){
       if(!selected){
           selected = d;
           d.selected = true;
        } 
        else {
           selected.selected = false;
           update(selected);
           selected = d;
           d.selected = true;
           
        }
        console.log("Selected node: ", selected);

        show_node_view(selected);

        if (selected.data.value == 1) {
          update_info_view("segment_view");
          new_selection = true;
        

          var selected_filters = selected.data.filters;
          if (dim) {
              dim.filterAll();
              reset_filters();

            }
          if(selected_filters) {

          console.log('SELECTED FILTERS', selected_filters);

          selected_filters.forEach(function(f){
              type = f.type;

              if (type == 'range') {
              
                var div = f.div;
                var extents = f.extents;

                current_chart = chart_data[div];
                dim = current_chart.dim;
                reset(current_chart.id);


                if (extents){

                  dim.filterFunction(function(d){
                    var inRange = true;
                    if (extents.pos)
                      inRange= inRange && (d >= extents.pos[0]) && (d <= extents.pos[1]);

                    extents.neg.forEach(function(ext){
                      inRange = inRange && !((d>=ext[0]) && (d<= ext[1]));

                    })

                    return inRange;
                  })
                }
                else
                  dim.filterExact(null);

              } else if (type == 'regex'){

                dim = action_strings;

                char_regex = f.regex;
                console.log('CHAR REGEX', char_regex);
                dim.filterFunction(function(d){


                    return d.match(char_regex);

                });
                
              }
              console.log('filtered-size', all.reduceCount().value());
              renderAll();

            })
            
          }
          new_selection = false;
          console.log('The current selection has ' + selected.data.size + ' sequences!' );
          contains_action();
          update_action_transition_graph();

        } 


        update(selected);
        showDiv();


    }




    function showDiv() {
      d3.select("#attributes").style("display", "block");
    }

    function add_child_node(d, node_obj, display) {

      var display = !display;
      if (d.children == null) {
          d.children = [];
        }

      node_obj.visible = 1;

      id = ++i;
      new_node = d3.hierarchy(node_obj);
      new_node.depth = d.depth + 1;
      new_node.height = d.height;
      new_node.parent = d;
      new_node.id = id;

      if (display)
        d.children.push(new_node);
      else{
        d.not_children = [];
        d.not_children.push(new_node);
      }


      return new_node;
      

    }


    //******** horizontal chart ***********
    var char;


    function reduceInitial() {
      return {
          count: 0
      };
    }

    function reduceAdd(p, v) {
      if (v.general_actions.includes(char))
        p.count = p.count + 1;
      
      return p;

    }

    function reduceRemove(p, v) {
      if (v.general_actions.includes(char))
        p.count = p.count - 1;
      
      return p;

    }

   


    function contains_action() {
      total_size = all.reduceCount().value();  
      all_matches = [];
      for(var char_key in alphabet_rev){
        char = char_key;
        matches = all.reduce(reduceAdd, reduceRemove, reduceInitial).value(); 
        
        if (matches){
          action = alphabet_rev[char_key];
          
          abs_matches = matches.count;
          //if char_key in current level of hierarchy!
          
          if (current_level.includes(action)) {
            percent_matches = abs_matches*100/total_size;
            
            m = { 'action': action, 'char': char_key, 'abs': abs_matches, 'percent': percent_matches, 'not_percent': 100-percent_matches}
            all_matches.push(m);
           }

        }
        
      }

      
      all_matches.sort(function(a,b) {return b.abs - a.abs;});
      
      update_horizontal_chart(all_matches);
    }
   
      var margin_hc = {top: 20, right: 20, bottom: 30, left: 100},
      width_hc = 300 - margin_hc.left - margin_hc.right,
      height_hc = 150 - margin_hc.top - margin_hc.bottom,
      horizontal_chart = d3.select("#contains_action_chart").append('svg').append("g").attr("transform", "translate(" + margin_hc.left + "," + margin_hc.top + ")");

      
      console.log('svg width', width_hc);
      console.log('svg height', height_hc);

      var x_hc = d3.scaleLinear()
              .rangeRound([0, width_hc]);

      var y_hc = d3.scaleBand()
              .rangeRound([0, height_hc])
              .paddingInner(0.1);

      var z_hc = d3.scaleOrdinal()
          .range(['steelblue', '#dee2e8'])

      var yAxis_hc = d3.axisLeft(y_hc);

    var selected_bar;

    function update_selected_bar(rect){
      //box = d3.select(rect).select(".outer_box")
      var box = rect;
                            
      if (selected_bar)
        selected_bar.style('stroke', "none");

      selected_bar = box;
      selected_bar.style("stroke", "black");


    }


    function update_horizontal_chart(data){

            //data = all_matches;
            //var keys = d3.keys(data[0]).filter(function(key) {return key !== "action" && key !== "abs";})
            var keys = ["percent", "not_percent"];

            z_hc.domain(keys);

            data.forEach(function (d) {
                var x0 = 0;
                d.percents = z_hc.domain().map(function (name) { return { name: name, value: d.abs, x0: x0, x1: x0 += +d[name] }; });
                d.total = d.percents[d.percents.length - 1].x1;

            });

            console.log('horizontal data', data);

            data.sort(function (a, b) { return b.total - a.total; });

            x_hc.domain([0,100]);
            y_hc.domain(data.map(function(d){return d.action;
                })
            );
           
               //drawing chart
            var bar = horizontal_chart
                .selectAll("g")
                    .remove()
                    .exit()
                    //.data(d3.stack().keys(keys)(data))
                    .data(data)
                    .enter().append("g")
                    .attr("transform", function (d) { return "translate(0," + y_hc(d.action) + ")"; })


                    
               var bar_enter = bar.selectAll("rect")
                    .remove()
                    .exit()
                    .data(d => d.percents)
                    .enter();

                  bar_enter.append("rect")
                        .attr("x", function(d){
                            return x_hc(d.x0);
                        })
                        .attr("height", function(d){
                            return y_hc.bandwidth();
                        })
                        .attr("width", function(d){
                            return x_hc(d.x1) - x_hc(d.x0);
                        })
                        .attr("fill", function(d) {return z_hc(d.name);});

                bar_enter.append("text")
                    .text(function(d) {
                          abs = d.value;
                         value = d.x1 - d.x0;
                         eligible = (d.name == "percent") && (value >= 0);
                         return  eligible ? d3.format(".1s")(abs) + ', ' + d3.format(",.0%")(value/100) : ""; 
                       })
                    .attr("x", function(d) {
                      if ((d.x1-d.x0) > 20)
                        return x_hc(d.x0)+(x_hc(d.x1) - x_hc(d.x0))/2 - 10;
                      else
                        return x_hc(d.x1 + 1);
                    })
                    .attr("y", y_hc.bandwidth()*3/4)
                    .style("fill", 'black');

                bar
                  .on("click", function(d) {
                    update_selected_bar(d3.select(this).select('.outer_box'));

                    selectedFilter.div = 'action_strings';
                    selectedFilter.chart = d3.select("#contains_action_chart");
                    selectedFilter.char = d.char;
                    selectedFilter.size = d.abs;
                    selectedFilter.type = 'regex'; 


                  })

                bar.append("rect")
                    .attr("class", "outer_box")
                    .attr("x", x_hc(0))
                    .attr("height", function(d){
                            return y_hc.bandwidth()
                        })
                    .attr("width", x_hc(100))
                    .attr("fill", "none");


              horizontal_chart.append('g').attr("class", "noAxis")
                          .call(yAxis_hc)

            


    }

    function update_thresholds(){

      console.log('current partitions', partitions);
      console.log('current x-range domain', x_range.domain());
      var x_min = x_range.domain()[0]
      var isNumber = false;
      if (typeof x_min == 'number')
        isNumber = true;
      new_thresholds = [x_range.domain()[0]]
      partitions.forEach(function(p) {
        var value = isNumber? parseFloat(p.value) : p.value;

        new_thresholds.push(value);
      })
      thresholds = new_thresholds.sort(function(a, b){return b-a});
      console.log('updated thresholds', thresholds);
    }

    function create_partition() {
      if (selected && selected_chart) {

        update_thresholds();
        

        var d = selected,
            dim,
            dims;

        chart_id = selected_chart.attr('id');


        name = 'NEW Partition!';
        partition_data = { 'name': name,
                     'value': 2,
                     'thresholds': thresholds.slice(),
                     'div': chart_id,
                     'chart': selected_chart

                   };
        partition_node = add_child_node(d, partition_data);

        

        chart_div = chart_data[chart_id];
        dim = chart_div.dim1;
        dims = chart_div.dims;



        console.log('thresholds for grouping', thresholds)
        console.log('Number of seqs: ', all.reduceCount().value())
        groups = dim.group(function(d) {
            return group_count(d, thresholds);
          }).all()

        partition = {};
        partition.div = chart_id;
        //partition.groups = groups;

        max_key = dims[dims.length-1].key;

        d_filters = d.data.filters;
        d_size = d.data.size;

        low_bound = 0;

        partition_data.partitions = [];
        partition_data.fullSize = d_size;
        
        for (var i = 0; i < groups.length; i++) {
          g = groups[i];
          low_bound = g.key;
          next = groups[i+1];
          if (next)
            high_bound = next.key;
          else
            high_bound = max_key;
          extents = [low_bound, high_bound];
          size = g.value;
          
          var partition = {};
          partition.range = extents;
          partition.size = size;
          partition.percent = size/d_size;
          partition_data.partitions.push(partition);
          // if (d_filters)
          //   filters = d_filters.slice();
          // else
          //   filters = [];

          var filter = {};
          filter.chart = selected_chart;
          filter.div = chart_id;
          filter.extents = extents;
          filter.type = 'range';
          //filters.push(filter);

          new_filters = create_new_filter_set(d_filters, filter);
          filters =new_filters[0];
          //filter = new_filters[1];

          name = 'NEW SEGMENT!'
          segment_data = { 'name': name,
                     'value': 1,
                     'filters': filters,
                     'size': size
                   };

          segment_node = add_child_node(partition_node, segment_data);

        }

   
        update(d);
        
      } else {
        if (!selected)
          alert('Segment was not selected!');
        else
          alert('Please choose range to filter!');
      } 



    }
    //    function update_extents(old_extents, new_extents){

      

    //   min = old_extents[0] < new_extents[0] ? old_extents : new_extents;
    //   max = min == old_extents ? new_extents : old_extents;

    //   if (min[1] < max[0])
    //     return null

    //   var updated_extents = {},
    //       updated_extents.pos = [],
    //       updated_extents.neg = [];

    //   updated_extents.pos = [max[0], (min[1]< max[1]? min[1]: max[1])];

    //   return updated_extents

    // }

    function update_extents(old_extents, new_extents, not){

      var not = not? true: false,
          updated_extents ={'pos':[], 'neg':[]};

      updated_extents.pos = old_extents.pos;
      updated_extents.neg = old_extents.neg.slice();

      if(not){
        updated_extents.neg.push(new_extents);
      }else{

        var old = old_extents.pos;
        if (old){ 
          min = old[0] < new_extents[0] ? old : new_extents;
          max = min == old ? new_extents : old;

          if (min[1] < max[0])
            updated_extents.pos = null;
          else
            updated_extents.pos = [max[0], (min[1]< max[1]? min[1]: max[1])];
        }else{
          updated_extents.pos = new_extents;
        }
      }
      console.log('UPDATED EXTENTS', updated_extents);
      return updated_extents

    }

    function create_action_regex(chars){
      s = '^'

      chars.pos.forEach( function(c){
        
        if (c instanceof Array){
          f = '';
          
          c.forEach(function(ch){
            f = f + ch + '.*';
          })
          c = f;
        }
        

        s = s + '(?=.*' + c + ')';
      })

      if (chars.neg.length>0){
      s = s + '(?!.*(';
        chars.neg.forEach( function(c){
          
          if (c instanceof Array){
            f = '(.*';
            
            c.forEach(function(ch){
              f = f + ch + '.*';
            })
            c = f +')';
          }
          

          s = s + c + '|';
        })
        s = s.slice(0,-1);
        s = s + '))';
      }

      s = s + '.*$';

      console.log('action regex created: ', s);

      return s;

    }



    function create_new_filter_set(old_set, new_filter, not) {
      var not_filter = false;
      if (not)
        not_filter = true;


      var filters,
          foundFilter=false,
          chart_div = new_filter.div;

       if (old_set)
          filters = old_set.slice();
        else
          filters = [];

        

        for( var f = 0; f < filters.length; f++){
          fil = filters[f];
          if (fil.div == chart_div){
            old_filter = fil;
            foundFilter = true;
            break;
          }
        }

        if (foundFilter){
          filters.splice(f, 1);
        }

        //if (!foundFilter){
        var filter = {};
        
        filter.div = chart_div;
        filter.not = not_filter;
        filter.chart = new_filter.chart;
        filters.push(filter);
        //}

        if (new_filter.type == 'range') {
          if (foundFilter){

            filter.extents = update_extents(old_filter.extents, new_filter.extents, not_filter);
          }
          else {
            filter.extents ={},
            filter.extents.neg =[],
            filter.extents.pos = null;

            if(not_filter)
              filter.extents.neg.push(new_filter.extents);
            else
              filter.extents.pos = new_filter.extents;


            //filter.extents = new_filter.extents;
            
          }
          filter.type = 'range';
          
        } else if(new_filter.type == 'regex') {
          filter.chars ={};
          filter.chars.pos =[],
          filter.chars.neg =[];

          if (foundFilter){
              filter.chars.pos = old_filter.chars.pos.slice();
              filter.chars.neg = old_filter.chars.neg.slice();
              //filter.chars.push(new_filter.char);
              
          }
          // else{
          //   filter.chars = [new_filter.char];
          // }
          if (not_filter){
            filter.chars.neg.push(new_filter.char);
          }else{
            filter.chars.pos.push(new_filter.char)
          }
          filter.regex = create_action_regex(filter.chars);
          filter.char = new_filter.char;
          filter.type = 'regex';
          console.log('CHARS', filter.chars);
        }

        // else if(new_filter.type == 'regex') {
        //   if (foundFilter){
        //       filter.chars = old_filter.chars.slice()
        //       filter.chars.push(new_filter.char);
              
        //   }
        //   else{
        //     filter.chars = [new_filter.char];
        //   }
        //   filter.regex = create_action_regex(filter.chars);
        //   filter.char = new_filter.char;
        //   filter.type = 'regex';
        // }

        //size = new_filter.size; 
        return [filters, filter];
    }
    function show_not_filter(){

      if(selected && selected.data.value==0){
        var d= selected;

        d.children.push(d.not_children[0]);

        update(selected);

      }else{
        alert('Please select filter')
      }
    }

    function create_filter(parent_segment) {

      var d = parent_segment || selected;

      // if (selected && selectedFilter.type) {

        //d = selected;
      if (d && selectedFilter.type) {
        d_filters = d.data.filters;

        new_filters = create_new_filter_set(d_filters, selectedFilter);
        filters =new_filters[0];
        filter = new_filters[1];


        prev_size = d.data.size;
        size = selectedFilter.size;

        not_filters = create_new_filter_set(d_filters, selectedFilter, true);



        

        name = 'NEW Filter!';
        filter_data = { 'name': name,
                     'value': 0,
                     'filter_type': filter

                   };

        filter_node = add_child_node(d, filter_data);
        

        var segment_data = { 'name': name,
                     'value': 1,
                     'filters': filters,
                     'size': size,
                     'prev_size': d.data.size
                   };

        var segment_node = add_child_node(filter_node, segment_data);


        var not_segment_data = { 'name': name,
                     'value': 1,
                     'filters': not_filters[0],
                     'size': prev_size - size,
                     'prev_size': prev_size
                   };

        var not_segment_node = add_child_node(filter_node, not_segment_data, true);

        selectedExtents = null;
        selectedChar = null;

        
        update(d);

        return filter_node;
        
      } else {
        if (!selected)
          alert('Segment was not selected!');
        else
          alert('Please choose range to filter!');

      }  



    }


    function toggle_segments(d){
      var treeData = tree(root);
      var nodes = treeData.descendants();

      nodes.forEach(function(d) {
            if (d.value == 1)
                 d.data.visible = 1 - d.data.visible;
        });

      update(root);
    }



    function remove_filter(){


      d = selected

      if (d.parent && d.parent.children && d.data.value !=1){
            console.log('removing ' + d.data.name);
            d.parent.children.forEach( function(n){
              if (n.id == d.id){
                nodeToDelete = n;

              }

            });
            console.log('node :', nodeToDelete);
            if (nodeToDelete){
                d.parent.children = _.without(d.parent.children, nodeToDelete);
                if(d.parent.children.length==0){
                  d.parent.children = null;
                };
            }
      } else {
        alert('Please select a filter to be removed!');
      } 


      update(d.parent)

    }

    function filter_partition(d){
      parent = d.parent;

      if (parent.data.value == 2) {
        parent.data.value = 3;
        parent._children = parent.children;
        parent.children = [];
        parent.children.push(d);
      } else if (parent.data.value == 3) {
        parent.data.value = 2;
        parent.children = parent._children;
      }
      update(parent);
    }


    function create_rect_path(d) {
        d = d.data;


        height = RECT_H; //fixed height
        //width = RECT_W;
        width = wScale(d.size)

        //parent_size = d.parent.size

        if (!d.visible) {
          height = 0;
          width = 0;
        }

        return 'M' + (-width/2) + ',' + (-height/2) +
          'l' + '0,' + height +
          'l' + width+ ',' + 0 +
          'l' + '0,' + -height +
          'l' + -width + ',0';


    }
    var only_path = 0

    var toggleColor = (function(){
       var currentColor = "white";

        return function(){
            currentColor = currentColor == "white" ? "magenta" : "white";
            d3.select(this).style("fill", currentColor);
        }
    })();

    var original_color = "white",
        pressed_color = "lightgray",
        current_color = original_color;

    function toggle_button_color(button_id){
      current_color = current_color == original_color? pressed_color : original_color;
      d3.select(button_id).style("background-color", current_color);
    }

    function show_path_only() {

      only_path = !only_path;

      toggle_button_color("#path_button")
      // current_color = current_color == original_color? pressed_color : original_color;
      // d3.select("#path_button").style("background-color", current_color);

      n = selected;

      while(n.value !=-1) {
          p = n.parent;
          if (only_path) {
            p._children = p.children;
            p.children = [];
            p.children.push(n);
          } else {
            p.children = p._children;
          }

          n = p;


      }

      update(root);

    }


  });
});

});

</script>
    
  </body>
</html>